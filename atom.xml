<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曹平的博客</title>
  
  <subtitle>一个菜鸡的学习记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.caopingping.com/"/>
  <updated>2019-05-15T09:22:08.097Z</updated>
  <id>http://www.caopingping.com/</id>
  
  <author>
    <name>曹平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>上呼吸道感染之前端安全</title>
    <link href="http://www.caopingping.com/2019/5/15/%E4%B8%8A%E5%91%BC%E5%90%B8%E9%81%93%E6%84%9F%E6%9F%93%E4%B9%8B%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    <id>http://www.caopingping.com/2019/5/15/上呼吸道感染之前端安全/</id>
    <published>2019-05-15T09:14:00.000Z</published>
    <updated>2019-05-15T09:22:08.097Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zy.caopingping.com/2019-5-15-上呼吸道感染之前端安全-2019-5-15-2.jpg-sy" alt="2019-5-15-上呼吸道感染之前端安全-2019-5-15-2" title="">                </div>                <div class="image-caption">2019-5-15-上呼吸道感染之前端安全-2019-5-15-2</div>            </figure><p>上呼吸道医生开药：头孢地尼，清热散结胶囊，喉咽清颗粒。记一下，事实证明自己买的药都是安慰剂。</p><h2 id="前端安全分类"><a href="#前端安全分类" class="headerlink" title="前端安全分类"></a>前端安全分类</h2><p>经典的前端攻击主要是两种：<code>XSS</code>和<code>CSRF</code></p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS（Cross-Site Scripting），跨站脚本攻击是一种代码注入攻击。攻击者在目标网站上注入恶意 JS 代码，当被攻击者访问被注入的网站时，这些恶意代码就会执行，这些代码可能是获取 Cookie，session，tokens 或者其他用户数据，甚至可以发起 XSS 蠕虫攻击。</p><p>根据 XSS 的来源，XSS 攻击可以分为三类：</p><ol><li>反射性（非持久型）</li><li>存储型（持久型）</li><li>DOM 型</li></ol><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 漏洞常见于通过<code>URL</code>传递参数的功能，如网站搜索，跳转等。反射型是最常用，也是使用得最广的一种攻击方式，由于需要用户主动打开恶意的<code>URL</code>才能生效，攻击者往往会通过许多手段诱导用户点击。</p><p>当用户点击一个恶意链接时，注入脚本进入被网站的服务器，如果该服务器存在 XSS 漏洞，脚本未被过滤被返回给浏览器，该脚本就会执行。</p><blockquote><p>反射型 XSS 的攻击步骤</p></blockquote><ol><li>攻击者构建出特殊的<code>URL</code>，其中包含恶意代码</li><li>当用户打开该链接时，网站服务器将恶意代码从 URL 中取出，拼接在 HTML 中并返回给浏览器</li><li>用户浏览器收到响应后解析并执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用网站接口执行某些操作。</li></ol><blockquote><p>反射型 XSS 实例：<a href="http://netsecurity.51cto.com/art/201311/417201.htm" target="_blank" rel="noopener">一个例子</a> 感谢这篇文章的作者。</p></blockquote><h3 id="反射型-XSS-的防范"><a href="#反射型-XSS-的防范" class="headerlink" title="反射型 XSS 的防范"></a>反射型 XSS 的防范</h3><p><strong>对字符串进行编码。</strong></p><p>对 url 参数要进行转义后再返回页面。</p><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>存储型 XSS 常见于带有用户保存数据的网站，如论坛发帖，评论，用户私信等。<br>恶意脚本被永久的存储在目标服务器上。每当浏览器请求相关数据时，恶意脚本就会被返回并执行，影响范围更大。</p><p>存储型 XSS 攻击的原因仍是没有做好数据过滤。<br>前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。</p><blockquote><p>存储型 XSS 的攻击步骤</p></blockquote><ol><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>当用户打开网站时，比如一个文章的评论区，网站服务器将恶意代码从数据库中取出来，拼接 HTML 返回给浏览器</li><li>浏览器收到响应后解释执行，其中的恶意代码也会执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用网站接口执行某些操作。</li></ol><p>每有一个用户访问这个文章的评论区，恶意代码都会执行一遍。</p><h3 id="反射型-XSS-的防范-1"><a href="#反射型-XSS-的防范-1" class="headerlink" title="反射型 XSS 的防范"></a>反射型 XSS 的防范</h3><p><strong>对字符串进行编码。</strong></p><ol><li>前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)</li><li>服务器接收到数据，在存储到数据库之前，进行转义/过滤</li><li>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤</li></ol><h3 id="DOM-型-XSS-攻击"><a href="#DOM-型-XSS-攻击" class="headerlink" title="DOM 型 XSS 攻击"></a>DOM 型 XSS 攻击</h3><p>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。</p><p>DOM 型 XSS 攻击，实际上就是前端 JavaScript 代码不够严谨，把不可信的内容插入到了页面。在使用 .innerHTML、.outerHTML、.appendChild、document.write()等 API 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 .innerText、.textContent、.setAttribute() 等。</p><blockquote><p>DOM 型 XSS 的攻击步骤：</p></blockquote><ol><li>击者构造出特殊数据，其中包含恶意代码。</li><li>用户浏览器执行了恶意代码。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><blockquote><p>DOM 型 XSS 实例：<a href="https://www.cnblogs.com/superye/p/7343676.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">一个例子</a> 再次感谢</p></blockquote><h3 id="DOM-型-XSS-的防范"><a href="#DOM-型-XSS-的防范" class="headerlink" title="DOM 型 XSS 的防范"></a>DOM 型 XSS 的防范</h3><p><strong>不要将用户输入的数据直接使用，加入 DOM</strong></p><ol><li>对于 url 链接(例如图片的 src 属性)，那么直接使用 encodeURIComponent 来转义。</li><li>非 url，我们可以这样进行编码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeHtml</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;apos;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h2><p>CSRF（cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入恶意网站，在恶意网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><blockquote><p>典型的 CSRF 攻击步骤：</p></blockquote><ol><li>受害者登录 A 站点，并保留了登录凭证（Cookie）</li><li>攻击者诱导受害者访问了站点 B。</li><li>站点 B 向站点 A 的服务器发送了一个请求，浏览器会默认携带站点 A 的 Cookie 信息。</li><li>站点 A 服务器接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。</li><li>站点 A 服务器以受害者的名义执行了站点 B 的请求。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zy.caopingping.com/2019-5-15-上呼吸道感染之前端安全-2019-5-15-1.jpg-sy" alt="2019-5-15-上呼吸道感染之前端安全-2019-5-15-1" title="">                </div>                <div class="image-caption">2019-5-15-上呼吸道感染之前端安全-2019-5-15-1</div>            </figure><blockquote><p>CSRF 的特点</p></blockquote><ol><li>攻击通常在第三方网站发起，如图上的站点 B，站点 A 无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取 cookie 信息(cookie 有同源策略)</li><li>跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等(来源不明的链接，不要点击)</li></ol><h3 id="CSRF-攻击的防范"><a href="#CSRF-攻击的防范" class="headerlink" title="CSRF 攻击的防范"></a>CSRF 攻击的防范</h3><ol><li><strong>添加验证码</strong><br>验证码能够防御 CSRF 攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。</li><li><p><strong>使用 Token(主流)</strong><br>CSRF 攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。</p><ul><li>服务端给用户生成一个 token，加密后传递给用户</li><li>用户在提交请求时，需要携带这个 token</li><li>服务端验证 token 是否正确</li></ul></li><li><p>判断请求的来源：检测 Referer(并不安全，Referer 可以被更改)<br><code>Referer</code> 可以作为一种辅助手段，来判断请求的来源是否是安全的，但是鉴于 <code>Referer</code> 本身是可以被修改的，因为不能仅依赖于 <code>Referer</code></p></li><li><p>Samesite Cookie 属性</p></li></ol><p>为了从源头上解决这个问题，Google 起草了一份草案来改进 HTTP 协议，为 Set-Cookie 响应头新增 Samesite 属性，它用来标明这个 Cookie 是个“同站 Cookie”，同站 Cookie 只能作为第一方 Cookie，不能作为第三方 Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。</p><p>部署简单，并能有效防御 CSRF 攻击，但是存在兼容性问题。</p><ol><li>Samesite=Strict<br><code>Samesite=Strict</code> 被称为是严格模式,表明这个 Cookie 在任何情况都不可能作为第三方的 Cookie，有能力阻止所有 CSRF 攻击。此时，我们在 B 站点下发起对 A 站点的任何请求，A 站点的 Cookie 都不会包含在 cookie 请求头中。</li><li>Samesite=Lax<br><code>Samesite=Lax</code> 被称为是宽松模式，与 Strict 相比，放宽了限制，允许发送安全 HTTP 方法带上 Cookie，如 <code>Get</code> / <code>OPTIONS</code> 、<code>HEAD</code> 请求.<br>但是不安全 HTTP 方法，如： <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 请求时，不能作为第三方链接的 Cookie</li></ol><p>为了更好的防御 CSRF 攻击，我们可以组合使用以上防御手段。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote><p>网站安全监测：<a href="https://github.com/mozilla/http-observatory/" target="_blank" rel="noopener">Mozilla HTTP Observatory</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
    
      <category term="面试" scheme="http://www.caopingping.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="安全" scheme="http://www.caopingping.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>很久之后之深拷贝</title>
    <link href="http://www.caopingping.com/2019/5/8/%E5%BE%88%E4%B9%85%E4%B9%8B%E5%90%8E%E4%B9%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://www.caopingping.com/2019/5/8/很久之后之深拷贝/</id>
    <published>2019-05-08T01:49:00.000Z</published>
    <updated>2019-05-08T01:49:45.517Z</updated>
    
    <content type="html"><![CDATA[<p>五一长假过去了，又该努力工作了呀，先回忆一下深拷贝吧，毕竟这是面试高发笔试题。</p><h2 id="变量的存储方式"><a href="#变量的存储方式" class="headerlink" title="变量的存储方式"></a>变量的存储方式</h2><ol><li>javascript变量包含两种不同数据类型的值：<code>基本类型和引用类型</code>。<ul><li>基本类型值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：number、string、boolean、null、undefined、symbol。</li><li>引用类型值指那些可能由多个值构成的对象，只有一种如下：object。 </li></ul></li><li>javascript的变量的存储方式：<code>栈（stack）</code>和<code>堆（heap）</code>。<ul><li>栈：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址（一个指针）</li><li>堆：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。</li></ul></li></ol><blockquote><p>基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。   </p><p>引用类型的值是保存在内存中的对象。JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。</p></blockquote><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>想当年很长时间都觉得 <code>Object.assign()</code> 就是深拷贝，其实不然。</p><ol><li>直接赋值</li><li>Object.assign(target,source)</li><li>…展开运算符</li></ol><blockquote><p>这些方法都不会深拷贝一个对象。<br>直接赋值相当于直接赋值对象的内存引用地址，assign和…都相当于是展开赋值，如果值是基本类型，那么会直接赋值，如果是引用类型，那么会赋值其引用对象的地址。</p></blockquote><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ol><li>JSON.parse(JSON.stringify(object))<br>简单直接的方法，但是当对象出现循环引用是会报错，并且无法拷贝Symbol，undefined，function，不可枚举属性</li><li>递归赋值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObj</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> source == <span class="string">'object'</span> || <span class="keyword">typeof</span> source == <span class="string">'function'</span>)&amp;&amp; source!<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只解决date，reg类型，其他的可以自己添加</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, hash = new Map(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cloneObj</span><br><span class="line">    <span class="keyword">let</span> Constructor = obj.constructor</span><br><span class="line">    <span class="keyword">switch</span>(Constructor)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">RegExp</span>:</span><br><span class="line">            cloneObj = <span class="keyword">new</span> Constructor(obj)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Date</span>:</span><br><span class="line">            cloneObj = <span class="keyword">new</span> Constructor(obj.getTime())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(hash.has(obj)) <span class="keyword">return</span> hash.get(obj) <span class="comment">// 针对环</span></span><br><span class="line">            cloneObj = <span class="keyword">new</span> Constructor()</span><br><span class="line">            hash.set(obj, cloneObj)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        cloneObj[key] = isObj(obj[key]) ? deepCopy(obj[key], hash) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;五一长假过去了，又该努力工作了呀，先回忆一下深拷贝吧，毕竟这是面试高发笔试题。&lt;/p&gt;
&lt;h2 id=&quot;变量的存储方式&quot;&gt;&lt;a href=&quot;#变量的存储方式&quot; class=&quot;headerlink&quot; title=&quot;变量的存储方式&quot;&gt;&lt;/a&gt;变量的存储方式&lt;/h2&gt;&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="JS" scheme="http://www.caopingping.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>愚人节之ES6-Proxy</title>
    <link href="http://www.caopingping.com/2019/4/2/%E6%84%9A%E4%BA%BA%E8%8A%82%E4%B9%8BES6-Proxy/"/>
    <id>http://www.caopingping.com/2019/4/2/愚人节之ES6-Proxy/</id>
    <published>2019-04-02T06:16:00.000Z</published>
    <updated>2019-04-02T06:16:59.961Z</updated>
    
    <content type="html"><![CDATA[<p>愚人节快乐。<br>复习一下 ES6 的 Proxy 新特性，即将到来的 vue3 也将用 Proxy 代替 Object.defineproperty 来实现数据响应式。</p><h2 id="Proxy-是什么"><a href="#Proxy-是什么" class="headerlink" title="Proxy 是什么"></a>Proxy 是什么</h2><p><code>Proxy</code>是 ES6 新增的功能，他可以用来自定义对象中的操作（如属性查找，赋值，枚举，函数调用等）。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>let p = new Proxy(target, handler);</p></blockquote><ul><li>target：用Proxy包装的目标对象，可以是任何类型的对象，包括原生数组，函数，甚至是另一个Proxy.</li><li>handler: 一个对象，其属性是当执行一个操作时，定义代理行为的函数。</li></ul><h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p>handler是一个占位符对象（placeholder object），包括了Proxy可以自定义的一些方法。</p><p>一共有 13 种可代理操作，每种操作的属性名和触发这种操作的方式列举如下。注意，如果没有定义某种操作，那么这种操作会被转发到目标对象身上。</p><ol><li><code>handler.getPrototypeOf()</code><br>在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</li><li><code>handler.setPrototypeOf()</code><br>在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</li><li><code>handler.isExtensible()</code><br>在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</li><li><code>handler.preventExtensions()</code><br>在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</li><li><code>handler.getOwnPropertyDescriptor()</code><br>在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, “foo”) 时。</li><li><code>handler.defineProperty()</code><br>在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, “foo”, {}) 时。</li><li><code>handler.has()</code><br>在判断代理对象是否拥有某个属性时触发该操作，比如在执行 “foo” in proxy 时。</li><li><code>handler.get()</code><br>在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</li><li><code>handler.set()</code><br>在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</li><li><code>handler.deleteProperty()</code><br>在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</li><li><code>handler.ownKeys()</code><br>在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</li><li><code>handler.apply()</code><br>当目标对象为函数，且被调用时触发。</li><li><code>handler.construct()</code><br>在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</li></ol><p>这些方法的参数基本上都有多个，各有异同，看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler#%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">文档</a>吧。</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ol><li><p>基础示例</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params">target,property,receiver</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'target'</span>,target)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'property'</span>,property)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'receiver'</span>,receiver)</span><br><span class="line">        <span class="keyword">return</span> target[property] + <span class="string">'_new'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">target, property, value, receiver</span>)</span>&#123;</span><br><span class="line">        target[property] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler)</span><br><span class="line"><span class="built_in">console</span>.log(p.a) <span class="comment">// 1_new</span></span><br></pre></td></tr></table></figure></li><li><p>为每一层都添加监控</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        c:<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params">target,property,receiver</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'target:'</span>,target)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'property:'</span>,property)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'receiver:'</span>,receiver)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> target[property] === <span class="string">'object'</span> &amp;&amp; target[property] !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target[property], handler);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property)+<span class="string">'new'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">target, property, value, receiver</span>)</span>&#123;</span><br><span class="line">        target[property] = value</span><br><span class="line">        <span class="built_in">console</span>.log(target[property],<span class="string">'changed'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler)</span><br><span class="line">p.b.c = <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;愚人节快乐。&lt;br&gt;复习一下 ES6 的 Proxy 新特性，即将到来的 vue3 也将用 Proxy 代替 Object.defineproperty 来实现数据响应式。&lt;/p&gt;
&lt;h2 id=&quot;Proxy-是什么&quot;&gt;&lt;a href=&quot;#Proxy-是什么&quot; class=
      
    
    </summary>
    
    
      <category term="JS" scheme="http://www.caopingping.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS的继承：原型链</title>
    <link href="http://www.caopingping.com/2019/3/22/JS%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9A%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://www.caopingping.com/2019/3/22/JS的继承：原型链/</id>
    <published>2019-03-22T06:28:00.000Z</published>
    <updated>2019-03-22T06:32:02.749Z</updated>
    
    <content type="html"><![CDATA[<p>撸一遍原型链及其相关的知识点。</p><h2 id="prototype和-proto-和constructor"><a href="#prototype和-proto-和constructor" class="headerlink" title="prototype和__proto__和constructor"></a>prototype和<code>__proto__</code>和constructor</h2><ul><li><code>prototype</code>是只有函数才有的属性。</li><li><code>__proto__</code>是每个对象都有的属性。</li></ul><p>现在我们的起点就是一个创建好的对象，由他开始寻找他的原型链。</p><h4 id="他的-proto-指向谁"><a href="#他的-proto-指向谁" class="headerlink" title="他的 __proto__ 指向谁"></a>他的 <code>__proto__</code> 指向谁</h4><p><code>__proto__</code>的指向取决于对象创建的方式。<br>下面这张图是三种常见方式创建对象后，<code>__proto__</code>指向谁。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2019-3-21-JS的继承：原型链-2019-3-21-0.png-sy" alt="`__proto__指向谁`" title="">                </div>                <div class="image-caption">`__proto__指向谁`</div>            </figure><h4 id="他的-constructor-指向谁"><a href="#他的-constructor-指向谁" class="headerlink" title="他的 constructor 指向谁"></a>他的 <code>constructor</code> 指向谁</h4><p>所有对象都会从他的原型上继承一个 <code>constructor</code> 属性,并且这个 <code>constructor</code> 等于他的构造函数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2019-3-21-JS的继承：原型链-2019-3-21-3.jpg-sy" alt="2019-3-21-JS的继承：原型链-2019-3-21-3" title="">                </div>                <div class="image-caption">2019-3-21-JS的继承：原型链-2019-3-21-3</div>            </figure><blockquote><p>即：<strong><code>a.constructor === A.prototype.constructor == A</code></strong><br>`</p></blockquote><h4 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h4><p>对于有基于类的语言经验 (如 Java 或 C++) 的coder来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个class实现。（在 ES2015/ES6 中引入了class关键字，但只是语法糖，JavaScript 仍然是基于原型的）。</p><p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为<code>__proto__</code>）指向它的原型对象（<code>prototype</code>）。该原型对象也有一个自己的私有属性(<code>__proto__</code>) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。</p><p>几乎所有 JavaScript 中的对象都是位于原型链顶端的Object的实例。</p><p>看一张图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2019-3-21-JS的继承：原型链-2019-3-21-2.png" alt="原型链" title="">                </div>                <div class="image-caption">原型链</div>            </figure></p><blockquote><p>注意 指向<code>Object.prototype</code>的是 <code>A.prototype.__proto__</code>，<br>而不是<code>A.__proto__</code>，而<code>A.__proto__</code>，下文解析。</p></blockquote><h2 id="Object和Function"><a href="#Object和Function" class="headerlink" title="Object和Function"></a>Object和Function</h2><p>你可能曾经发现过这么一个现象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>什么鬼？我们先说一下instanceof</p><h4 id="instanceof究竟是运算什么的"><a href="#instanceof究竟是运算什么的" class="headerlink" title="instanceof究竟是运算什么的"></a>instanceof究竟是运算什么的</h4><p>对于 <strong><code>object instanceof constructor</code></strong> </p><p>简单的来说：<strong>instanceof运算符用于 测试 object的原型链中的 任何位置 是否存在constructor的prototype属性</strong></p><blockquote><p>注意：instanceof运算时会递归查找object的原型链，即<code>object.__proto__.__proto__.__proto__.__proto__...</code>直到找到了或者找到顶层为止。</p></blockquote><h4 id="再说Object和Function"><a href="#再说Object和Function" class="headerlink" title="再说Object和Function"></a>再说Object和Function</h4><ol><li><p>Function</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__) <span class="comment">// function() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype) <span class="comment">// function() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__===<span class="built_in">Function</span>.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p> <code>Function</code>的<code>__proto__</code>就是他自己的<code>prototype</code>,并且是一个特殊的匿名函数。</p></li><li><p>Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__) <span class="comment">// function() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype) <span class="comment">// Object的函数们，原型链的终点</span></span><br></pre></td></tr></table></figure><p>我们发现<code>Object.__proto__</code>也是一个匿名函数，那么他与<code>Function</code>的<code>__proto__</code>是同一个吗？</p></li><li><p>Function与Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__===<span class="built_in">Function</span>.__proto__) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>果然是同一个，那么这个特殊的匿名函数又在其中扮演什么角色呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> her = <span class="built_in">Function</span>.__proto__ <span class="comment">// 那个匿名函数</span></span><br><span class="line"><span class="built_in">console</span>.log(her.__proto__) <span class="comment">//竟然是Object.prototype?</span></span><br><span class="line"><span class="built_in">console</span>.log(her.prototype) </span><br><span class="line"><span class="comment">//当然是undefined的了 Object.prototype没有prototype</span></span><br></pre></td></tr></table></figure></li><li><p>关系图<br><img src="http://zy.caopingping.com/2019-3-21-JS的继承：原型链-2019-3-22-0.jpg-sy" alt="关系图"></p><blockquote><p>终点还是 <code>Object.prototype</code></p></blockquote></li><li><p>结果<br>根据上面的分析，我们知道了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object instanceof Function</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function instanceof Object</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p>还有下面的运算也是应有之理了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.constructor === <span class="built_in">Function</span> </span><br><span class="line"><span class="built_in">Function</span>.constructor === <span class="built_in">Function</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="一个并没有什么用的小结论"><a href="#一个并没有什么用的小结论" class="headerlink" title="一个并没有什么用的小结论"></a>一个并没有什么用的小结论</h2><blockquote><p>所有构造器的constructor都指向Function<br>Function的prototype指向一个特殊的匿名函数，而这个匿名函数的<code>__proto__</code>指向Object.prototype</p></blockquote><p>所有的结论都会很快的遗忘，只有真正的理解其中的过程才是正理。<br>当然了，过程也是会忘的<br>所以要写下来呀 🐶</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文部分图源 <a href="https://www.cnblogs.com/shuiyi/p/5305435.html#4131165" target="_blank" rel="noopener">感谢博主</a></p><p>FLAG-1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;撸一遍原型链及其相关的知识点。&lt;/p&gt;
&lt;h2 id=&quot;prototype和-proto-和constructor&quot;&gt;&lt;a href=&quot;#prototype和-proto-和constructor&quot; class=&quot;headerlink&quot; title=&quot;prototype和_
      
    
    </summary>
    
    
      <category term="JS" scheme="http://www.caopingping.com/tags/JS/"/>
    
      <category term="面试" scheme="http://www.caopingping.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>知识点整理-JS</title>
    <link href="http://www.caopingping.com/2019/3/20/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-JS/"/>
    <id>http://www.caopingping.com/2019/3/20/知识点整理-JS/</id>
    <published>2019-03-20T07:07:00.000Z</published>
    <updated>2019-05-09T08:02:26.507Z</updated>
    
    <content type="html"><![CDATA[<p>此文是对常见 JS 基础方面的面试题整理。</p><h2 id="继承：原型链"><a href="#继承：原型链" class="headerlink" title="继承：原型链"></a>继承：原型链</h2><p>与原型链相关的三个概念：</p><ul><li>prototype(原型)：一个对象，用于实现对象的<strong>属性继承</strong>。</li><li>constructor(构造函数)：一个可以 new 的函数。只有函数才有 prototype。</li><li>instance(实例)：构造函数 new 出来的对象，有一个<code>__proto__</code>属性，等于其父亲的 prototype。<br>三者关系见下一篇文章(FLAG!!)</li></ul><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>执行上下文，Execution Context，简称 EC</p><h3 id="内存空间的分配"><a href="#内存空间的分配" class="headerlink" title="内存空间的分配"></a>内存空间的分配</h3><p>首先了解一下执行上下文的存放<br>JS 的基础数据类型有 Undefined、Null、Boolean、Number、String，这些都是按值访问，存放在栈内存。<br>其他的 Object 为引用类型，如数组 Array 或其他的自定义对象，这些存放在堆内存，其对应的地址引用（指针）放在栈内存。</p><h3 id="EC-的类型"><a href="#EC-的类型" class="headerlink" title="EC 的类型"></a>EC 的类型</h3><ol><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ol><h3 id="EC-的组成"><a href="#EC-的组成" class="headerlink" title="EC 的组成"></a>EC 的组成</h3><p>EC 由一下三部分组成，可以把它当做一个简单的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">testEC = &#123;</span><br><span class="line">  VO: &#123;&#125;,</span><br><span class="line">  scopeChain: &#123;&#125;,</span><br><span class="line">  <span class="keyword">this</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>VO：变量对象，包括当前 EC 中创建的所有变量和函数声明(不包含函数表达式)</li><li>scopeChain：作用域链，是由当前内存中各个变量对象 VO 串起来的单向链表，每入栈执行一个 function，其对应的 VO 就添加到作用域链的头部，前一个 VO 能自由访问到下一个 VO 上的变量，反过来就不行。<blockquote><p>作用域链可以理解为一组对象列表，包含父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。<br>这个对象由两部分构成</p><ol><li><code>[[scope]]</code>属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和 AO</li><li>AO: 自身活动对象</li></ol></blockquote></li><li>this：this 的指向，是在执行上下文被创建时确定的，也就是说 this 是在函数执行时确定的。</li></ul><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>先看一段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> anotherColor = <span class="string">'red'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempColor = anotherColor</span><br><span class="line">    anotherColor = color</span><br><span class="line">    color = tempColor</span><br><span class="line">  &#125;</span><br><span class="line">  swapColors()</span><br><span class="line">&#125;</span><br><span class="line">changeColor()</span><br></pre></td></tr></table></figure><p>当代码执行时，首先创建全局执行上下文（global EC）并入栈，每进入一个 function，就做一次入栈操作，向栈顶压入一个属于该 function 的新的 EC。若 function 中又调用了另一个 function，则再执行一次入栈…依次执行完再依次出栈，回到全局 EC。全局 EC 一定是在栈底，在浏览器关闭后出栈。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2019-3-20-知识点整理-JS-2019-3-30-1.png-sy" alt="执行上下文图解" title="">                </div>                <div class="image-caption">执行上下文图解</div>            </figure><blockquote><p>本节图片来源： <a href="https://mp.weixin.qq.com/s/hRE3HzeSxxok1bLI8vH1yw" target="_blank" rel="noopener">感谢博主</a></p></blockquote><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域其实可理解为<code>该上下文</code>中声明的变量的作用范围。可分为 全局作用局、局部作用域（函数作用域）。<br>ES6 引入 let 后，块级作用域开始起作用。</p><p>作用域会声明提前：一个声明在其作用域内都是可见的，函数提升优于变量提升。</p><p><strong>函数的父级作用域，是函数定义的时候的父级作用域，不是函数执行的时候的父级作用域，即函数在哪定义，父级作用域就在什么地方</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">  test()</span><br><span class="line">&#125;</span><br><span class="line">b() <span class="comment">//结果为2而不是3</span></span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包属于一种特殊的作用域，称为 <strong>静态作用域</strong>。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。</p><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><p>那个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  clickObj[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：当 for 循环完成是，声明了 i 个 function，他们的父级作用域都是全局作用域。函数体内的 <code>i</code> 并没有被赋值，而是等待 click 事件，当事件触发时，函数运行，在自己的作用域内没有找到 <code>i</code> ,于是向自己的父级作用域寻找 <code>i</code>,于是找到 <code>i=10</code>。</p><p>解决：生成闭包,保存父级的作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  ;(<span class="function"><span class="keyword">function</span>(<span class="params">ind</span>) </span>&#123;</span><br><span class="line">    clickObj[ind].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(ind)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="script-引入方式"><a href="#script-引入方式" class="headerlink" title="script 引入方式"></a>script 引入方式</h2><ol><li>HTML 静态 <code>&lt;script&gt;</code> 引入</li><li>JS 动态插入</li><li><code>&lt;script defer&gt;</code></li><li><code>&lt;script async&gt;</code></li></ol><blockquote><p><strong><code>最稳妥的做法还是把&lt;script&gt;写在&lt;body&gt;底部，没有兼容性问题，没有白屏问题，没有执行顺序问题，高枕无忧，不要搞什么defer和async的花啦~</code></strong></p></blockquote><p>之间的区别一图胜千言<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2019-3-20-知识点整理-JS-2019-3-30-2.png-sy" alt="区别图" title="">                </div>                <div class="image-caption">区别图</div>            </figure></p><h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><ul><li>浅拷贝：以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响<ul><li>Object.assign(target,..source)</li><li>展开运算符（…）</li></ul></li><li>深拷贝：完全拷贝一个新对象，与原对象毫不相干。<ul><li>JSON.parse(JSON.stringify(object))：速度最快<ul><li>如果对象存在循环引用，会报错</li><li>当值为 undefined、任意的函数以及 symbol 值，会被忽略</li><li>不可枚举的属性会被忽略</li></ul></li><li>递归赋值</li></ul></li></ul><h2 id="new-运算符的执行过程"><a href="#new-运算符的执行过程" class="headerlink" title="new 运算符的执行过程"></a>new 运算符的执行过程</h2><ol><li>生成一个空的简单对象{}</li><li>将该对象的<code>__proto__</code>链接到他的构造函数的 <code>prototype</code></li><li>将创建的对象作为<code>this</code>的上下文</li><li>如果构造函数没有返回对象，则返回<code>this</code></li></ol><h2 id="继承之圣杯模式"><a href="#继承之圣杯模式" class="headerlink" title="继承之圣杯模式"></a>继承之圣杯模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> grailMode = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Origin, Target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Temp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    Temp.prototype = Origin.prototype</span><br><span class="line">    Target.prototype = <span class="keyword">new</span> Temp()</span><br><span class="line">    Target.prototype.constructor = Target</span><br><span class="line">    Target.prototype.ancestor = Origin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ChinaPerson = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">grailMode(Person, ChinaPerson)</span><br></pre></td></tr></table></figure><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>现阶段来说，我们在浏览器中使用 ES6 的模块化支持，在 nodejs 中使用 commonjs 的模块化支持。</p><ol><li><p>分类</p><ul><li>ES6 <code>import/export</code></li><li>commonjs <code>require/module.exports/exports</code></li><li>amd <code>require/defined</code></li></ul></li><li><p>require 与 import 的区别</p><ul><li><code>require</code>支持动态导入，<code>import</code>不支持，正在提案（babel 下支持）</li><li><code>require</code>是同步导入，<code>import</code>是异步</li><li><code>require</code>是值拷贝，<code>import</code>指向内存地址</li></ul></li></ol><h2 id="函数执行改变-this"><a href="#函数执行改变-this" class="headerlink" title="函数执行改变 this"></a>函数执行改变 this</h2><ol><li><code>call: fn.call(target, 1, 2)</code></li><li><code>apply: fn.apply(target, [1, 2])</code> 参数为数组</li><li><code>bind: fn.bind(target)(1,2)</code></li></ol><blockquote><p>call 和 apply 是立即执行；bind 返回一个函数，等待调用</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>此文持续更新！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此文是对常见 JS 基础方面的面试题整理。&lt;/p&gt;
&lt;h2 id=&quot;继承：原型链&quot;&gt;&lt;a href=&quot;#继承：原型链&quot; class=&quot;headerlink&quot; title=&quot;继承：原型链&quot;&gt;&lt;/a&gt;继承：原型链&lt;/h2&gt;&lt;p&gt;与原型链相关的三个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="JS" scheme="http://www.caopingping.com/tags/JS/"/>
    
      <category term="面试" scheme="http://www.caopingping.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>知识点整理-CSS</title>
    <link href="http://www.caopingping.com/2019/3/19/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-CSS/"/>
    <id>http://www.caopingping.com/2019/3/19/知识点整理-CSS/</id>
    <published>2019-03-19T07:13:00.000Z</published>
    <updated>2019-03-19T07:14:13.041Z</updated>
    
    <content type="html"><![CDATA[<p>一看离上次写文已经三个月了竟然，果然坚持是最难的呀，过完年忙碌了两个月，该复习一下了，说不定什么时候找工作呢。</p><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>当对文档进行布局（lay out）的时候，浏览器渲染引擎会根据CSS基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子。</p><blockquote><p>每个盒子由四部分组成：内容content，内边界paddingm，边框border和外边界margin。而box-sizing属性定义了浏览器该如何计算盒子的总宽度和总高度。</p><ul><li><code>content-box</code> 标准盒模型，width与height只包含content的宽高。</li><li><code>border-box</code> IE盒模型，本人布局最爱，width和height包含content，padding，border，不包括margin。</li><li><code>padding-box</code> width 和 height 属性包括内容和内边距，但是不包括边框和外边距。只有Firefox实现了这个值，它在Firefox 50中被<code>删除</code>。</li><li><code>margin-box</code> 无浏览器实现</li></ul></blockquote><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><p>BFC包含创建它的元素内部的所有内容。  </p><ul><li>触发条件<ol><li>根元素</li><li>浮动 float != none</li><li>定位 position == absolute|fixed</li><li>dispaly display == inline-block|table</li><li>overflow overflow != visible</li></ol></li><li>表现<ol><li>在一个BFC中，垂直方向上，盒子是从包含块顶部开始一个一个布局的，两个相邻的盒子的垂直距离是有margin属性决定的，两个相邻的块级盒子的垂直外边距会产生塌陷。</li><li>在一个BFC中，水平方向上，每个盒子的左边缘都会接触包含块的左边缘（从右向左的格式则相反），<strong>除非出现浮动元素和其他元素相互作用的情况</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context#Specifications" target="_blank" rel="noopener">经典案例</a></li></ol></li><li>应用<ol><li>消除垂直外边距塌陷。</li><li>可以包含浮动元素，解决高度塌陷。</li><li>创建自适应布局 参考经典案例</li></ol></li></ul><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>一图说明<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/blog/2019-3-19-1.webp-sy" alt="层叠上下文" title="">                </div>                <div class="image-caption">层叠上下文</div>            </figure></p><h2 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与 @import 的区别"></a>link 与 @import 的区别</h2><ol><li><p>从属关系区别<br>@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。</p></li><li><p>加载顺序区别<br>加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</p></li><li><p>兼容性区别<br>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。</p></li><li><p>DOM可控性区别<br>可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。</p></li></ol><h2 id="写在后边"><a href="#写在后边" class="headerlink" title="写在后边"></a>写在后边</h2><p>此文会持久更新，在此立下FLAG！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一看离上次写文已经三个月了竟然，果然坚持是最难的呀，过完年忙碌了两个月，该复习一下了，说不定什么时候找工作呢。&lt;/p&gt;
&lt;h2 id=&quot;盒模型&quot;&gt;&lt;a href=&quot;#盒模型&quot; class=&quot;headerlink&quot; title=&quot;盒模型&quot;&gt;&lt;/a&gt;盒模型&lt;/h2&gt;&lt;p&gt;当对文
      
    
    </summary>
    
    
      <category term="面试" scheme="http://www.caopingping.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="CSS" scheme="http://www.caopingping.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>图片上传方案详解</title>
    <link href="http://www.caopingping.com/2019/1/3/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.caopingping.com/2019/1/3/图片上传方案详解/</id>
    <published>2019-01-03T08:56:00.000Z</published>
    <updated>2019-01-03T08:57:42.154Z</updated>
    
    <content type="html"><![CDATA[<p>以往用到图片上传功能都是直接使用现成的插件，今天把其中用到的知识点整理一下。</p><h2 id="知识点字典"><a href="#知识点字典" class="headerlink" title="知识点字典"></a>知识点字典</h2><ul><li>input 标签之 file 类型</li><li>FileReader 对象：读取文件</li><li>FileReader.readAsDataURL()：将读取的文件转换为 base64 编码的字符串</li><li>FormData 对象</li><li>使用 axios 上传</li></ul><h3 id="input-标签之-file-类型"><a href="#input-标签之-file-类型" class="headerlink" title="input 标签之 file 类型"></a>input 标签之 file 类型</h3><p>当设置 input 标签 type 为 file 时，input 表现性状为上传文件样式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2019-1-3-图片上传方案研究-2019-1-3-1.png" alt="默认样式" title="">                </div>                <div class="image-caption">默认样式</div>            </figure><p>file-input 有如下属性：</p><ol><li>accept<br>指定选择文件类型的范围。默认为所有文件类型<br>图片为 accept=”image/*“<br>文件类型取值见<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#Unique_file_type_specifiers" target="_blank" rel="noopener">MDN</a></li><li>capture<br>当文件类型为图片或视频且在移动端时，此属性才有意义。<ul><li>capture = ‘user’ 调用前置摄像头</li><li>capture = ‘environment’ 调用后置摄像头</li><li>不设置则为用户自己选择</li></ul></li><li>multiple<br>一个 Boolean 值，如果存在，则表示用户可以选择多个文件</li><li>files<br>返回一个 FileList，列出每个所选文件对象。除非 multiple 指定了属性，否则此列表只有一个成员。主要用于 JS 操作。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">multiple</span> <span class="attr">id</span>=<span class="string">"imgLocal"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">let</span> inp = <span class="built_in">document</span>.querySelector(<span class="string">'#imgLocal'</span>)</span><br><span class="line">inp.onchange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fileList = <span class="built_in">document</span>.querySelector(<span class="string">'#imgLocal'</span>).files</span><br><span class="line">  <span class="built_in">console</span>.log(fileList) <span class="comment">//files</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileReader-对象"><a href="#FileReader-对象" class="headerlink" title="FileReader 对象"></a>FileReader 对象</h2><p>我们用 FileReader 对象实现图片预览功能。</p><p>FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>new FileReader()</strong></p><p>返回一个新构造的 FileReader。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>FileReader.readyState<br>表示 FileReader 状态的数字，取值如下<ul><li>0：EMPTY/还没有加载任何数据</li><li>1：LOADING/数据正在被加载</li><li>2：DONE/已完成全部的读取请求</li></ul></li><li>FileReader.result<br>文件的内容。该属性仅在读取操作完成后才有效。</li><li>FileReader.error</li></ul><h3 id="事件及方法"><a href="#事件及方法" class="headerlink" title="事件及方法"></a>事件及方法</h3><p>我们主要是用 <strong>FileReader.onload</strong> 事件及 <strong>FileReader.readAsDataURL()</strong> 方法，其他见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader#Method_overview" target="_blank" rel="noopener">MDN</a></p><ul><li>FileReader.onload<br>处理 load 事件。该事件在读取操作完成时触发</li><li>FileReader.readAsDataURL()<br>开始读取指定的 Blob 中的内容。一旦完成，result 属性中将包含一个 data: URL 格式的字符串以表示所读取文件的内容。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继续使用上文的fileList</span></span><br><span class="line"><span class="keyword">let</span> file = fileList[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader()</span><br><span class="line">fileReader.readAsDataURL(file) <span class="comment">//读取图片</span></span><br><span class="line">fileReader.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取完成</span></span><br><span class="line">  <span class="keyword">let</span> res = fileReader.result</span><br><span class="line">  <span class="comment">// res是base64格式的图片</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们将 DOM 上 img 的 src 设为读取的结果即可实现预览功能。</p><h2 id="FormData-对象"><a href="#FormData-对象" class="headerlink" title="FormData 对象"></a>FormData 对象</h2><p>FormData 对象的使用：</p><ol><li>用一些键值对来模拟一系列表单控件：即把 form 中所有表单元素的 name 与 value 组装成<br>一个 queryString</li><li>异步上传二进制文件。</li></ol><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>new FormData()</strong></p><p>返回一个新构造的 FormData。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>FormData 方法有很多。我们这里只用了她的 append()方法</p><blockquote><p>formData.append(name, value, filename)</p></blockquote><ul><li>name:属性名</li><li>value:属性值，在我们这里则指 file 数据</li><li>filename:当第二个参数为 file 或 blob 时，告诉服务器的文件名。Blob 对象的默认文件名是“blob”。File 对象的默认文件名 是文件的文件名。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继续使用上文的file</span></span><br><span class="line"><span class="keyword">const</span> formDate = <span class="keyword">new</span> FormData()</span><br><span class="line">formDate.append(<span class="string">'userPicture'</span>, file, <span class="string">'1.jpg'</span>)</span><br></pre></td></tr></table></figure><h2 id="使用-axios-上传"><a href="#使用-axios-上传" class="headerlink" title="使用 axios 上传"></a>使用 axios 上传</h2><p>主要是设置 header 中的 Content-Type</p><p>直接上代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继续使用上文的formDate</span></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">axios</span><br><span class="line">  .post(<span class="string">'serverUrl'</span>, formDate, config)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>axios 亦可 使用onUploadProgress监听上传进度，不再赘述。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他还有直接form表单提交文件等方式，可能不太自由。诸位有兴趣的可以看一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以往用到图片上传功能都是直接使用现成的插件，今天把其中用到的知识点整理一下。&lt;/p&gt;
&lt;h2 id=&quot;知识点字典&quot;&gt;&lt;a href=&quot;#知识点字典&quot; class=&quot;headerlink&quot; title=&quot;知识点字典&quot;&gt;&lt;/a&gt;知识点字典&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;input 
      
    
    </summary>
    
    
      <category term="JS" scheme="http://www.caopingping.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Array和Object的迭代</title>
    <link href="http://www.caopingping.com/2019/1/2/Array%E5%92%8CObject%E7%9A%84%E8%BF%AD%E4%BB%A3/"/>
    <id>http://www.caopingping.com/2019/1/2/Array和Object的迭代/</id>
    <published>2019-01-02T10:31:00.000Z</published>
    <updated>2019-01-03T01:44:44.244Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是为了记录以下几个比较容易记忆混乱的方法</p><ul><li>for…in (hasOwnProperty)</li><li>for…of</li><li>Object.keys()</li><li>Object.getOwnPropertyNames()</li></ul><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>使用for..in循环时，返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例（<font color="OrangeRed">实例+原型中的可枚举属性</font>）</p><h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><p>for..in操作的主要目的就是遍历对象的属性，如果只需要获取对象自身的实例属性，可以使用hasOwnProperty()进行过滤。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">let</span> cpp = <span class="keyword">new</span> Person(<span class="string">'cpp'</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> cpp) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop); <span class="comment">// name age getName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hasOwn = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop2 <span class="keyword">in</span> cpp) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn.call(cpp, prop2)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop2); <span class="comment">// name age</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p><strong>for…in</strong>主要用用于遍历对象，但同样也可以遍历数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`索引<span class="subst">$&#123;i&#125;</span>：<span class="subst">$&#123;arr[i]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是为什么大家都说不推荐使用<strong>for…in</strong>来遍历数组呢，总结了一下一共有三个理由</p><ol><li><p>如果扩展了原生的Array，那么扩展的属性会被for..in输出 </p><blockquote><p>for..in 会遍历原型中的属性，所以，无论是遍历数组还是对象，如果在原型中添加的属性的enumerable为true,都会被for..in 遍历出来</p><p>可以使用Object.defineProperty添加，并设置 enumerable为false</p></blockquote></li><li><p>对于不存在的数组项的处理</p><p>对于数组来讲，我们知道如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>,<span class="string">'yellow'</span>,<span class="string">'blue'</span>]</span><br><span class="line">colors.length = <span class="number">5</span> </span><br><span class="line">colors.push(<span class="string">'orange'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> colors)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(colors[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为 'red' 'yellow' 'blue' 'orange'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;colors.length;i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(colors[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为 'red' 'yellow' 'blue' undefined undefined 'orange'</span></span><br></pre></td></tr></table></figure><p>可见for..in 循环数组不会枚举不存在的项，但这些项在内存中是真实存在的，我们可以删除这些项，也可以给他们赋值。</p></li><li><p>遍历顺序</p><p>数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同。不能保证for … in将以任何特定的顺序返回索引。for … in循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些。</p><p>因为迭代的顺序是依赖于执行环境的，所以数组遍历<strong>不一定按次序访问元素</strong>。</p></li></ol><h2 id="for…of-与-for…in-的区别"><a href="#for…of-与-for…in-的区别" class="headerlink" title="for…of 与 for…in 的区别"></a>for…of 与 for…in 的区别</h2><p><strong>ES6新增for…of</strong><br>for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句  </p><p>无论是for…in还是for…of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。</p><ul><li><p>for…in 语句以原始插入顺序迭代对象的可枚举属性。</p></li><li><p>for…of 语句遍历可迭代对象定义要迭代的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 0, 1, 2, "foo", "arrCustom", "objCustom"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (iterable.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 0, 1, 2, "foo"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 3, 5, 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>for…of 是根据 要迭代的数据的迭代器进行遍历的<br>迭代器可以自定义<br>需要定义要迭代数据的 <strong>Symbol.iterator</strong></p><p>Object没有默认的迭代器，所以默认for…of不能用于Object</p><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p>Object.keys()用于获取对象自身所有的可枚举的，但<strong>不包括原型中的属性</strong>，然后返回一个由属性名组成的数组。<br>一个例子理解:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>,<span class="string">'yellow'</span>,<span class="string">'blue'</span>]</span><br><span class="line">colors.length = <span class="number">5</span> </span><br><span class="line">colors.push(<span class="string">'orange'</span>)</span><br><span class="line"><span class="built_in">Array</span>.prototype.demo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(colors); <span class="comment">// ["0", "1", "2", "10"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.demo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cpp = <span class="keyword">new</span> Person(<span class="string">'cpp'</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(cpp); <span class="comment">// ["name", "age"]</span></span><br></pre></td></tr></table></figure></p><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>Object.getOwnPropertyNames()方法返回对象的所有自身属性的属性名（<strong>包括不可枚举属性但不包括Symbol值作为名称的属性</strong>）组成的数组，但<strong>不会获取原型链上的属性</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a,aa</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">  <span class="keyword">this</span>.getA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">A.prototype.aaa = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="keyword">new</span> A(<span class="string">'b'</span>, <span class="string">'bb'</span>);</span><br><span class="line"><span class="comment">//自身方法</span></span><br><span class="line">B.myMethodA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 不可枚举方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(B, <span class="string">'myMethodB'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(B); </span><br><span class="line"><span class="comment">//结果 ["a", "getA", "myMethodA", "myMethodB"]</span></span><br></pre></td></tr></table></figure><blockquote><p>只获取自身不可枚举属性：使用 <strong>Object.getOwnPropertyNames()</strong> 获得所有自身属性，通过 <strong>Object.keys()</strong> 获得自身可枚举属性，通过filter函数筛选即可。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>名称</th><th>适用</th><th>描述</th></tr></thead><tbody><tr><td>for in</td><td>数组 对象</td><td>实例+原型 的可枚举属性</td></tr><tr><td>for of</td><td>有迭代器的可迭代对象（Array,Map,Set等）</td><td>返回属性值</td></tr><tr><td>Object.keys()</td><td>数组 对象</td><td>获取对象自身所有的可枚举的属性</td></tr><tr><td>Object.getOwnPropertyNames()</td><td>数组 对象</td><td>获取对象的所有自身属性的属性名，包括不可枚举属性但不包括Symbol值作为名称的属性</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章是为了记录以下几个比较容易记忆混乱的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for…in (hasOwnProperty)&lt;/li&gt;
&lt;li&gt;for…of&lt;/li&gt;
&lt;li&gt;Object.keys()&lt;/li&gt;
&lt;li&gt;Object.getOwnPropertyNames(
      
    
    </summary>
    
    
      <category term="JS" scheme="http://www.caopingping.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存整理</title>
    <link href="http://www.caopingping.com/2018/12/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.caopingping.com/2018/12/29/浏览器缓存整理/</id>
    <published>2018-12-29T06:55:00.000Z</published>
    <updated>2018-12-29T06:56:24.796Z</updated>
    
    <content type="html"><![CDATA[<p>对浏览器缓存这一块一直是乱哄哄的状态，今天终于有时间整理一下，写下这篇笔记，以供日后查阅。</p><h2 id="缓存概述"><a href="#缓存概述" class="headerlink" title="缓存概述"></a>缓存概述</h2><p>良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度<br>通常浏览器缓存策略分为两种：强缓存和协商缓存</p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li>浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。</li><li>如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源</li><li>如果前面两者都没有命中，直接从服务器加载资源</li></ol><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>强缓存不发请求到服务器，协商缓存会发请求到服务器。</p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存通过<strong>Expires</strong>和<strong>Cache-Control</strong>两种响应头实现  </p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。<br>Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Sat, 29 Sep 2018 14:20:00 GMT</span><br></pre></td></tr></table></figure><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control 出现于 HTTP / 1.1，<strong>优先级高于 Expires</strong> ,表示的是相对时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=315360000</span><br></pre></td></tr></table></figure></p><p>Cache-Control在request和response中都可以使用</p><ol><li>在请求中使用Cache-Control 时，它可选的值有：</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2018-12-29-1.png-sy" alt="Cache-Control在请求头中的取值" title="">                </div>                <div class="image-caption">Cache-Control在请求头中的取值</div>            </figure><ol start="2"><li>在响应中使用Cache-Control 时，它可选的值有：</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2018-12-29-浏览器缓存整理-2018-12-29-2.png-sy" alt="Cache-Control在响应头中的取值" title="">                </div>                <div class="image-caption">Cache-Control在响应头中的取值</div>            </figure><h3 id="强缓存流程图"><a href="#强缓存流程图" class="headerlink" title="强缓存流程图"></a>强缓存流程图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2018-12-29-浏览器缓存整理-2018-12-29-3.png-sy" alt="强缓存流程图" title="">                </div>                <div class="image-caption">强缓存流程图</div>            </figure><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串</p><p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的</p><h3 id="Last-Modified，If-Modified-Since"><a href="#Last-Modified，If-Modified-Since" class="headerlink" title="Last-Modified，If-Modified-Since"></a>Last-Modified，If-Modified-Since</h3><p>Last-Modified 表示请求来的文件的最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p><h3 id="ETag、If-None-Match"><a href="#ETag、If-None-Match" class="headerlink" title="ETag、If-None-Match"></a>ETag、If-None-Match</h3><p>Etag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的</p><p>If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来</p><p>ETag的优先级比Last-Modified更高</p><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><ol><li>客户端请求一个页面（A）。</li><li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。</li><li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。</li><li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。</li><li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</li></ol><h3 id="感觉两个功能重复了？"><a href="#感觉两个功能重复了？" class="headerlink" title="感觉两个功能重复了？"></a>感觉两个功能重复了？</h3><h4 id="ETag对Last-Modified的补充"><a href="#ETag对Last-Modified的补充" class="headerlink" title="ETag对Last-Modified的补充"></a>ETag对Last-Modified的补充</h4><p>首先Last-Modified在http/1.0中被提出，而在http/1.1中提出的ETag则是为了解决Last-Modified<strong>无法解决的一些问题</strong></p><ol><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ol><h4 id="Last-Modified对ETag的补充"><a href="#Last-Modified对ETag的补充" class="headerlink" title="Last-Modified对ETag的补充"></a>Last-Modified对ETag的补充</h4><p>一些图片等静态文件的修改，如果每次扫描内容生成 ETag 来比较，显然要比直接比较修改时间慢很多</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>所以说两者并不是互斥，而是相辅相成的关系，既可以单独使用，又可以同时使用。</p><p>同时传入服务器时，服务器可以根据自己的缓存机制的需要，选择ETag或者是Last-Modified来做缓存判断的依据，甚至可以两个同时参考。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote><p>协商缓存需要配合强缓存使用，如果不启用强缓存的话，协商缓存根本没有意义</p></blockquote><p>大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】</p><blockquote><p>Apache对于静态内容默认会返回Last-modified和ETag.</p><p>Nginx只会返回Last-modified(可配置etag on开启).</p></blockquote><p>但是下面的场景需要注意：</p><ul><li>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</li><li>分布式系统尽量关闭掉ETag（每台机器生成的ETag都会不一样）</li></ul><h2 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2018-12-29-浏览器缓存整理-2018-12-29-4.png-sy" alt="浏览器缓存整理" title="">                </div>                <div class="image-caption">浏览器缓存整理</div>            </figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/amandakelake/blog/issues/41" target="_blank" rel="noopener">https://github.com/amandakelake/blog/issues/41</a><br><a href="https://blog.csdn.net/u012375924/article/details/82806617" target="_blank" rel="noopener">https://blog.csdn.net/u012375924/article/details/82806617</a><br><a href="https://segmentfault.com/q/1010000004200644" target="_blank" rel="noopener">https://segmentfault.com/q/1010000004200644</a><br>baidu and google</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对浏览器缓存这一块一直是乱哄哄的状态，今天终于有时间整理一下，写下这篇笔记，以供日后查阅。&lt;/p&gt;
&lt;h2 id=&quot;缓存概述&quot;&gt;&lt;a href=&quot;#缓存概述&quot; class=&quot;headerlink&quot; title=&quot;缓存概述&quot;&gt;&lt;/a&gt;缓存概述&lt;/h2&gt;&lt;p&gt;良好的缓存策略可以
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://www.caopingping.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之数据属性和访问器属性</title>
    <link href="http://www.caopingping.com/2018/12/28/JavaScript%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%E5%92%8C%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.caopingping.com/2018/12/28/JavaScript之数据属性和访问器属性/</id>
    <published>2018-12-28T08:25:00.000Z</published>
    <updated>2018-12-28T08:27:43.608Z</updated>
    
    <content type="html"><![CDATA[<p>在javaScript中，对象的属性分为两种类型：数据属性和访问器属性。</p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含的是一个数据值的位置，在这可以对数据值进行读写。</p><p>数据属性包含四个特性，分别是：</p><ul><li><p>configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为true</p></li><li><p>enumerable:表示能否通过for-in循环返回属性</p></li><li><p>writable：表示能否修改属性的值</p></li><li><p>value：包含该属性的数据值。默认为undefined</p></li></ul><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值，包含的是一对get和set方法，在读写访问器属性时，就是通过这两个方法来进行操作处理的。</p><p>访问器属性包含的四个特性：</p><ul><li><p>configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为false</p></li><li><p>enumerable:表示能否通过for-in循环返回属性,默认为false</p></li><li><p>Get：在读取属性时调用的函数,默认值为undefined</p></li><li><p>Set：在写入属性时调用的函数,默认值为undefined</p></li></ul><h3 id="属性的读取与修改"><a href="#属性的读取与修改" class="headerlink" title="属性的读取与修改"></a>属性的读取与修改</h3><blockquote><p>对象的属性通过 <strong>Object.getOwnPropertyDescriptor()</strong> 获取</p></blockquote><blockquote><p>对象的属性通过 <strong>Object.defineProperty()</strong> 修改</p></blockquote><p>数据属性和访问器属性是同级别的关系，只是由于功能不同把它们分成两派，按照它们所谓的 “特征值” 定义这个属性的性质。访问器属性只是因为它带有可以访问对象内其它属性的功能（通过 getter、setter 函数），并经过一些处理从而实现 “设置一个属性的值会导致其他属性发生变化”的效果。</p><blockquote><p>如果一个对象属性同时有(value或writable)和(get或set)关键字，将会产生一个异常</p></blockquote><blockquote><p>如果只指定get方法,不指定set方法，那么这个属性是只读的，反之则是只写的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">_b</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">'a'</span>) </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    value: 1, </span></span><br><span class="line"><span class="comment">    writable: true, </span></span><br><span class="line"><span class="comment">    enumerable: true, </span></span><br><span class="line"><span class="comment">    configurable: true</span></span><br><span class="line"><span class="comment">  &#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//修改数据属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'a'</span>,&#123;</span><br><span class="line">  value: <span class="number">100</span>, </span><br><span class="line">  writable: <span class="literal">false</span>, </span><br><span class="line">  enumerable: <span class="literal">false</span>, </span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">'a'</span>) </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    value: 100, </span></span><br><span class="line"><span class="comment">    writable: false, </span></span><br><span class="line"><span class="comment">    enumerable: false, </span></span><br><span class="line"><span class="comment">    configurable: true</span></span><br><span class="line"><span class="comment">  &#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 修改访问器属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'b'</span>,&#123;</span><br><span class="line">  get()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._b</span><br><span class="line">  &#125;,</span><br><span class="line">  set(newVal)&#123;</span><br><span class="line">    <span class="keyword">this</span>._b = <span class="keyword">this</span>._b + newVal</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.b) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在javaScript中，对象的属性分为两种类型：数据属性和访问器属性。&lt;/p&gt;
&lt;h3 id=&quot;数据属性&quot;&gt;&lt;a href=&quot;#数据属性&quot; class=&quot;headerlink&quot; title=&quot;数据属性&quot;&gt;&lt;/a&gt;数据属性&lt;/h3&gt;&lt;p&gt;数据属性包含的是一个数据值的位置，在
      
    
    </summary>
    
    
      <category term="JS" scheme="http://www.caopingping.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP系统学习</title>
    <link href="http://www.caopingping.com/2018/12/27/HTTP%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.caopingping.com/2018/12/27/HTTP系统学习/</id>
    <published>2018-12-27T07:16:00.000Z</published>
    <updated>2018-12-27T08:48:28.036Z</updated>
    
    <content type="html"><![CDATA[<p>虽然日常都离不开HTTP，平时HTTP学习的很多，但是都很零碎，今天就把HTTP系统的整理一遍，形成一个完整的知识闭环。以下章节排序不是HTTP时序。</p><h2 id="http简介"><a href="#http简介" class="headerlink" title="http简介"></a>http简介</h2><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。  </p><p>HTTP是一个基于TCP/IP通信协议来传递数据。</p><h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h3><p>HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p>HTTP默认端口号为80。</p><p><strong>http有三个特点</strong></p><ul><li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li></ul><p>但是随着时间的推移，网页越来越复杂，传统的无连接无状态就变得很低效，所以对针对无连接，Keep-Alive被提了出来，cookie,session等保持HTTP连接的技术也应运而生</p><h3 id="3-各版本HTTP"><a href="#3-各版本HTTP" class="headerlink" title="3.各版本HTTP"></a>3.各版本HTTP</h3><ul><li>HTTP/0.9<br>只有一个命令GET<br>没有HEADER等描述数据的信息<br>服务器发送完毕，就关闭TCP连接  </li><li>HTTP/1.0<br>增加了很多命令<br>增加status code和header<br>多字符集支持、多部分发送、权限、缓存等  </li><li>HTTP/1.1<br>持久连接<br>pipeline<br>增加host和其他一些命令  </li><li>HTTP2<br>所有数据以二进制传输<br>同一个连接里面发送多个请求不再需要按照顺序来<br>头信息压缩以及推送等提高效率的功能  </li></ul><p>目前使用最广泛的还是HTTP1.1</p><h3 id="4-HTTPS"><a href="#4-HTTPS" class="headerlink" title="4.HTTPS"></a>4.HTTPS</h3><p>HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><p>我们这里只简单提一下HTTPS，主要学习HTTP</p><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/blog/2018-12-27-1.webp" alt="请求报文" title="">                </div>                <div class="image-caption">请求报文</div>            </figure><h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1.请求行"></a>1.请求行</h4><p>请求行分为三部分，请求方法，请求地址，协议版本</p><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p><p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p><h5 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h5><p>URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。</p><blockquote><p>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; </p></blockquote><p>端口和路径有时可以省略（HTTP默认端口号是80）</p><p>GET请求会带参数</p><h5 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h5><p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p><h4 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2.请求头部"></a>2.请求头部</h4><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</p><table><thead><tr><th style="text-align:left">Headers</th><th style="text-align:left">解释</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">Accept</td><td style="text-align:left">指定客户端能够接收的内容类型</td><td style="text-align:left">Accept: text/plain, text/html</td></tr><tr><td style="text-align:left">Accept-Encoding</td><td style="text-align:left">指定浏览器可以支持的web服务器返回内容压缩编码类型。</td><td style="text-align:left">Accept-Encoding: gzip</td></tr><tr><td style="text-align:left">Cache-Control</td><td style="text-align:left">指定请求和响应遵循的缓存机制</td><td style="text-align:left">Cache-Control: no-cache</td></tr><tr><td style="text-align:left">Host</td><td style="text-align:left">指定请求的服务器的域名和端口号</td><td style="text-align:left">Host: <a href="http://www.caopingping.com">www.caopingping.com</a></td></tr><tr><td style="text-align:left">Connection</td><td style="text-align:left">表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td><td style="text-align:left">Connection:keep-alive</td></tr><tr><td style="text-align:left">referer</td><td style="text-align:left">先前网页的地址，当前请求网页紧随其后,即来路</td><td style="text-align:left">Referer: <a href="http://www.caopingping.com/about">http://www.caopingping.com/about</a></td></tr><tr><td style="text-align:left">User-Agent</td><td style="text-align:left">User-Agent的内容包含发出请求的用户信息</td><td style="text-align:left">User-Agent: Mozilla/5.0 (Linux; X11)</td></tr></tbody></table><p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p><h4 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3.请求数据"></a>3.请求数据</h4><p>请求数据可选，比如GET请求没有请求数据</p><p>下面是一个POST请求的请求报文</p><blockquote><p>POST 　/index.php　HTTP/1.1  请求行<br>  Host: localhost  请求头<br>  User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2<br>  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8<br>  Accept-Language: zh-cn,zh;q=0.5<br>  Accept-Encoding: gzip, deflate<br>  Connection: keep-alive<br>  Referer: <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a><br>  Content-Length：25<br>  Content-Type：application/x-www-form-urlencoded<br>　　      <code>空行</code><br>  username=aa&amp;password=1234　　请求数据  </p></blockquote><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2018-12-27-2.webp" alt="响应报文" title="">                </div>                <div class="image-caption">响应报文</div>            </figure><p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p><h4 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h4><p>由3部分组成，分别为：协议版本，状态码，状态码描述。</p><p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p>状态代码为3位数字。<br>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。  </p><p>下面列举几个常见的：</p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr></tbody></table><h4 id="2-响应头部"><a href="#2-响应头部" class="headerlink" title="2.响应头部"></a>2.响应头部</h4><p>与请求头部类似，为响应报文添加了一些附加信息<br>常见响应头部如下：</p><table><thead><tr><th style="text-align:left">Header</th><th style="text-align:left">解释</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">Allow</td><td style="text-align:left">对某网络资源的有效的请求行为，不允许则返回405</td><td style="text-align:left">Allow: GET, HEAD</td></tr><tr><td style="text-align:left">Cache-Control</td><td style="text-align:left">告诉所有的缓存机制是否可以缓存及哪种类型</td><td style="text-align:left">Cache-Control: no-cache</td></tr><tr><td style="text-align:left">Content-Encoding</td><td style="text-align:left">web服务器支持的返回内容压缩编码类型。</td><td style="text-align:left">Content-Encoding: gzip</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">返回内容的MIME类型</td><td style="text-align:left">Content-Type: text/html; charset=utf-8</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">原始服务器消息发出的时间</td><td style="text-align:left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td style="text-align:left">ETag</td><td style="text-align:left">请求变量的实体标签的当前值</td><td style="text-align:left">ETag: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:left">Expires</td><td style="text-align:left">响应过期的日期和时间</td><td style="text-align:left">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td style="text-align:left">Expires</td><td style="text-align:left">响应过期的日期和时间</td><td style="text-align:left">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td style="text-align:left">Last-Modified</td><td style="text-align:left">请求资源的最后修改时间</td><td style="text-align:left">Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr><tr><td style="text-align:left">Server</td><td style="text-align:left">web服务器软件名称</td><td style="text-align:left">Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td style="text-align:left">Expires</td><td style="text-align:left">响应过期的日期和时间</td><td style="text-align:left">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr></tbody></table><h4 id="2-响应数据"><a href="#2-响应数据" class="headerlink" title="2.响应数据"></a>2.响应数据</h4><p>用于存放需要返回给客户端的数据信息。</p><h2 id="HTTP请求与响应的过程"><a href="#HTTP请求与响应的过程" class="headerlink" title="HTTP请求与响应的过程"></a>HTTP请求与响应的过程</h2><h3 id="TCP-IP协议模型"><a href="#TCP-IP协议模型" class="headerlink" title="TCP/IP协议模型"></a>TCP/IP协议模型</h3><p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。</p><p>HTTP协议就是基于TCP/IP协议模型来传输信息的。</p><p>下面这张图可以清楚的看明白TCP/IP模型的角度下HTTP请求与响应的过程</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2018-12-27-4.webp" alt="TCP/IP模型的角度下HTTP请求与响应" title="">                </div>                <div class="image-caption">TCP/IP模型的角度下HTTP请求与响应</div>            </figure><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2018-12-27-5.webp" alt="TCP三次握手" title="">                </div>                <div class="image-caption">TCP三次握手</div>            </figure><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；  </p><p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><blockquote><p>为什么要三次握手</p></blockquote><blockquote><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p></blockquote><blockquote><p>例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。</p></blockquote><p>现在就可以进行数据请求了，也就是上文的请求与响应。</p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2018-12-27-6.webp" alt="TCP四次挥手" title="">                </div>                <div class="image-caption">TCP四次挥手</div>            </figure><p>第一次分手：主机1（可以是客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><blockquote><p>为什么要四次分手</p></blockquote><blockquote><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一图以蔽之</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zy.caopingping.com/2018-12-27-7.webp" alt="HTTP流程总结" title="">                </div>                <div class="image-caption">HTTP流程总结</div>            </figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/c1d6a294d3c0" target="_blank" rel="noopener">https://www.jianshu.com/p/c1d6a294d3c0</a><br><a href="https://blog.csdn.net/qq_33616529/article/details/78288883" target="_blank" rel="noopener">https://blog.csdn.net/qq_33616529/article/details/78288883</a><br>百度<br>Google  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然日常都离不开HTTP，平时HTTP学习的很多，但是都很零碎，今天就把HTTP系统的整理一遍，形成一个完整的知识闭环。以下章节排序不是HTTP时序。&lt;/p&gt;
&lt;h2 id=&quot;http简介&quot;&gt;&lt;a href=&quot;#http简介&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://www.caopingping.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>linux下git免登陆设置</title>
    <link href="http://www.caopingping.com/2018/11/16/linux%E4%B8%8Bgit%E5%85%8D%E7%99%BB%E9%99%86%E8%AE%BE%E7%BD%AE/"/>
    <id>http://www.caopingping.com/2018/11/16/linux下git免登陆设置/</id>
    <published>2018-11-16T07:51:00.000Z</published>
    <updated>2018-11-16T07:53:45.930Z</updated>
    
    <content type="html"><![CDATA[<p>使用Git的时候，每次操作都得输入用户名密码，神烦啊！<br>网上找了资料很快就弄好了，做个记录，以备不时之需。</p><h3 id="1-创建-git-credentials文件"><a href="#1-创建-git-credentials文件" class="headerlink" title="1.创建.git-credentials文件"></a>1.创建.git-credentials文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root</span><br><span class="line">vim .git-credentials</span><br></pre></td></tr></table></figure><p>在文件中写入</p><blockquote><p><code>https://{username}:{password}@github.com</code></p></blockquote><p>即你的用户名密码，保存退出。</p><h3 id="2-在终端下执行"><a href="#2-在终端下执行" class="headerlink" title="2.在终端下执行"></a>2.在终端下执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><h3 id="3-查看是否成功"><a href="#3-查看是否成功" class="headerlink" title="3.查看是否成功"></a>3.查看是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /root/.gitconfig</span><br></pre></td></tr></table></figure><p>如果多了一项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]</span><br><span class="line">helper = store</span><br></pre></td></tr></table></figure><p>设置成功。下次就不用再输入用户名密码了。   </p><p>美滋滋。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Git的时候，每次操作都得输入用户名密码，神烦啊！&lt;br&gt;网上找了资料很快就弄好了，做个记录，以备不时之需。&lt;/p&gt;
&lt;h3 id=&quot;1-创建-git-credentials文件&quot;&gt;&lt;a href=&quot;#1-创建-git-credentials文件&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="git" scheme="http://www.caopingping.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建过程记录</title>
    <link href="http://www.caopingping.com/2018/11/15/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.caopingping.com/2018/11/15/hexo博客搭建过程记录/</id>
    <published>2018-11-15T04:50:00.000Z</published>
    <updated>2018-11-16T08:10:18.026Z</updated>
    
    <content type="html"><![CDATA[<p>以前一直用的github.io搭的自己的博客，总觉得差点意思，还是自己整个服务器吧，以下是在阿里云centos7下完成的，记录一下。</p><h2 id="Node环境与Git安装"><a href="#Node环境与Git安装" class="headerlink" title="Node环境与Git安装"></a>Node环境与Git安装</h2><p>hexo基于nodeJs，所以首先要安装node</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line">wget https://nodejs.org/dist/v10.13.0/node-v10.13.0-linux-x64.tar.xz</span><br><span class="line">tar -xvf node-v10.13.0-linux-x64.tar.xz</span><br><span class="line">mv node-v10.13.0-linux-x64  nodejs</span><br></pre></td></tr></table></figure><p>可以到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a>下载需要的node版本，如果下载sourceCode源码版本，需要自己编译很长时间，不推荐，我下载的Linux Binaries (x64)</p><p>查看 nodejs文件夹 下有是否有node 和npm文件，如果没有重新下载安装。</p><h3 id="建立软链接"><a href="#建立软链接" class="headerlink" title="建立软链接"></a>建立软链接</h3><p>将npm和node命令转为全局命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/src/nodejs/bin/npm /usr/local/bin/npm</span><br><span class="line">ln -s /usr/local/src/nodejs/bin/node /usr/local/bin/node</span><br></pre></td></tr></table></figure><h3 id="检验node是否已全局可用"><a href="#检验node是否已全局可用" class="headerlink" title="检验node是否已全局可用"></a>检验node是否已全局可用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><p>如果想使用cnpm 可以全局安装后，建立软链接，同2，不再赘述</p><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><h3 id="全局安装hexo"><a href="#全局安装hexo" class="headerlink" title="全局安装hexo"></a>全局安装hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="初始化hexo项目"><a href="#初始化hexo项目" class="headerlink" title="初始化hexo项目"></a>初始化hexo项目</h3><p>进入hexo项目文件夹，我的是在/home/apps/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home/apps/</span><br><span class="line">hexo init hexoblog</span><br><span class="line">cd hexoblog</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>安装完成后目录如下</p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul><ol><li>配置</li></ol><p>网站的初始配置都在_config.yml中，我们可以在其中修改大部分配置。</p><p>具体配置见 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener"><code>hexo官网</code></a></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>安装完成后，hollow world 终于可以打开了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/apps/hexoblog</span><br><span class="line">hexo s</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>现在打开服务器ip 4000 端口即可看到Hellow world 页面啦<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pi40bre2b.bkt.clouddn.com/2018-11-15-hexo博客搭建过程记录-20181115.png-sy" alt="2018-11-15-hexo博客搭建过程记录-20181115" title="">                </div>                <div class="image-caption">2018-11-15-hexo博客搭建过程记录-20181115</div>            </figure></p><h3 id="主题的使用"><a href="#主题的使用" class="headerlink" title="主题的使用"></a>主题的使用</h3><p>hexo安装完成后切换主题极其简单，我现在用的是Material Design 风格的Hexo主题 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener"><code>indigo</code></a> ,<br>更多主题可以在 <a href="https://hexo.io/themes/" target="_blank" rel="noopener"><code>官网</code></a> 查看，选择你心仪的主题即可，亦可自己开发DIY。</p><blockquote><p>别忘了给作者start哦</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/apps/hexoblog/</span><br><span class="line">git clone https://github.com/yscoder/hexo-theme-indigo.git themes/indigo</span><br></pre></td></tr></table></figure><p>然后将_config.yml中 <code>theme</code> 选项设为 <code>indigo</code> 即可</p><p>此主题需要安装依赖，具体步骤查看作者文档 <a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="noopener"><code>文档</code></a></p><h3 id="hexo管理工具"><a href="#hexo管理工具" class="headerlink" title="hexo管理工具"></a>hexo管理工具</h3><p>如果我们每次写完都要把文件传到服务器，再 <code>hexo g -d</code>,那岂不是很麻烦，当然也可以接受，不过hexo-admin可以更方便的管理你的博文，是你在随便一个浏览器即可写作，美滋滋</p><p>看这里即可，使用极其简单</p><blockquote><p><a href="https://jaredforsyth.com/hexo-admin/" target="_blank" rel="noopener">hexo-admin</a></p></blockquote><p>##结束</p><p>如果不出意外，现在你已经可以写文章了，具体的文章写作和加载，请直接看官网吧。有啥意外可以问我😀😀😀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前一直用的github.io搭的自己的博客，总觉得差点意思，还是自己整个服务器吧，以下是在阿里云centos7下完成的，记录一下。&lt;/p&gt;
&lt;h2 id=&quot;Node环境与Git安装&quot;&gt;&lt;a href=&quot;#Node环境与Git安装&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://www.caopingping.com/tags/hexo/"/>
    
      <category term="node" scheme="http://www.caopingping.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>centos下nginx的安装与自启</title>
    <link href="http://www.caopingping.com/2018/11/14/centos%E4%B8%8Bnginx%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%87%AA%E5%90%AF/"/>
    <id>http://www.caopingping.com/2018/11/14/centos下nginx的安装与自启/</id>
    <published>2018-11-14T07:49:00.000Z</published>
    <updated>2018-11-16T08:08:38.184Z</updated>
    
    <content type="html"><![CDATA[<p>老早就想买个服务器，可惜囊中羞涩，一直没有下手，前两天逛阿里云看见个云翼计划，赶紧踩着青春的尾巴买了一年ECS<br>自己没事耍耍也是好的呀</p><blockquote><p><a href="https://promotion.aliyun.com/ntms/act/campus2018.html" target="_blank" rel="noopener">阿里云翼计划</a>  </p></blockquote><p>废话不多说，这就开始</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>服务器一台 我用的是阿里云centos7</li><li>xshell 其它亦可</li><li>linux基本操作</li></ol><h2 id="nginx和配置"><a href="#nginx和配置" class="headerlink" title="nginx和配置"></a>nginx和配置</h2><p>我们一会还要安装node，node自己本身可以作为服务器进行驱动，但是node本身对文件的处理能力并不是很好，所以当我们的生产环境中应尽量使用nginx来处理静态的资源以及反向代理，同时也解决了node分布式以及负载均衡的相关问题。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>首先安装make gcc之类的东西，编译用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install automake autoconf libtool make</span><br><span class="line">yum install gcc gcc-c++</span><br></pre></td></tr></table></figure></li><li><p>选择nginx安装目录，我选的是 /usr/local/src</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br></pre></td></tr></table></figure></li><li><p>一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.42.tar.gz</span><br><span class="line">tar -zxvf pcre-8.42.tar.gz</span><br><span class="line">cd pcre-8.42</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol><p>可以在<a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a>选择最新版本pcre</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line">cd zlib-1.2.11</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>可以在<a href="http://zlib.net/" target="_blank" rel="noopener">http://zlib.net/</a>选择最新版本zlib</p><ol start="4"><li>安装ssl<br>网络通信安全，功能丰富且自包含的开源安全工具箱<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.openssl.org/source/openssl-1.1.1.tar.gz</span><br><span class="line">tar -zxvf openssl-1.1.1.tar.gz</span><br></pre></td></tr></table></figure></li></ol><p>可以在<a href="https://www.openssl.org/source/" target="_blank" rel="noopener">https://www.openssl.org/source/</a>选择最新版本openssl</p><ol start="4"><li>安装nginx</li></ol><p>Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.4.2.tar.gz</span><br><span class="line">tar -zxvf nginx-1.4.2.tar.gz</span><br><span class="line">cd nginx-1.4.2</span><br><span class="line"> </span><br><span class="line">./configure --sbin-path=/usr/local/nginx/nginx \</span><br><span class="line">--conf-path=/usr/local/nginx/nginx.conf \</span><br><span class="line">--pid-path=/usr/local/nginx/nginx.pid \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-pcre=/usr/src/local/pcre-8.42 \</span><br><span class="line">--with-zlib=/usr/src/local/zlib-1.2.11 \</span><br><span class="line">--with-openssl=/usr/src/local/openssl-1.1.1</span><br><span class="line"> </span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>–with-pcre=/usr/src/local/pcre-8.42 指的是pcre-8.42 的源码路径。<br>–with-zlib=/usr/src/local/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。</p><h3 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h3><p>安装成功后 /usr/local/nginx 目录下如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">drwx------  2 nobody root    4096 Nov  2 10:16 client_body_temp</span><br><span class="line">-rw-r--r--  1 root   root    1034 Nov  1 18:43 fastcgi.conf</span><br><span class="line">-rw-r--r--  1 root   root    1034 Nov  1 18:43 fastcgi.conf.default</span><br><span class="line">-rw-r--r--  1 root   root     964 Nov  1 18:43 fastcgi_params</span><br><span class="line">-rw-r--r--  1 root   root     964 Nov  1 18:43 fastcgi_params.default</span><br><span class="line">drwx------  2 nobody root    4096 Nov  2 10:16 fastcgi_temp</span><br><span class="line">drwxr-xr-x  2 root   root    4096 Nov  2 11:11 html</span><br><span class="line">-rw-r--r--  1 root   root    2837 Nov  1 18:43 koi-utf</span><br><span class="line">-rw-r--r--  1 root   root    2223 Nov  1 18:43 koi-win</span><br><span class="line">drwxr-xr-x  2 root   root    4096 Nov  2 10:16 logs</span><br><span class="line">-rw-r--r--  1 root   root    3463 Nov  1 18:43 mime.types</span><br><span class="line">-rw-r--r--  1 root   root    3463 Nov  1 18:43 mime.types.default</span><br><span class="line">-rwxr-xr-x  1 root   root 7177456 Nov  1 18:43 nginx</span><br><span class="line">-rw-r--r--  1 root   root    3937 Nov 13 16:14 nginx.conf</span><br><span class="line">-rw-r--r--  1 root   root    2685 Nov  1 18:43 nginx.conf.default</span><br><span class="line">-rw-r--r--  1 root   root       5 Nov 12 10:02 nginx.pid</span><br><span class="line">drwx------ 12 nobody root    4096 Nov 13 15:29 proxy_temp</span><br><span class="line">-rw-r--r--  1 root   root     596 Nov  1 18:43 scgi_params</span><br><span class="line">-rw-r--r--  1 root   root     596 Nov  1 18:43 scgi_params.default</span><br><span class="line">drwx------  2 nobody root    4096 Nov  2 10:16 scgi_temp</span><br><span class="line">-rw-r--r--  1 root   root     623 Nov  1 18:43 uwsgi_params</span><br><span class="line">-rw-r--r--  1 root   root     623 Nov  1 18:43 uwsgi_params.default</span><br><span class="line">drwx------  2 nobody root    4096 Nov  2 10:16 uwsgi_temp</span><br><span class="line">-rw-r--r--  1 root   root    3610 Nov  1 18:43 win-utf</span><br></pre></td></tr></table></figure></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure><p>现在打开浏览器，输入此机器IP即可看到  </p><blockquote><p>Welcome To Nginx</p></blockquote><p>安装成功！</p><h3 id="将nginx加入可执行程序目录"><a href="#将nginx加入可执行程序目录" class="headerlink" title="将nginx加入可执行程序目录"></a>将nginx加入可执行程序目录</h3><p>竟然每次操作nginx都要进入/usr/local/nginx/<br>好麻烦有木有<br>没关系 软链接来帮你<br>/usr/local/bin目录是给用户放置自己的可执行程序的地方,<br>我们只需在这里建立nginx的软链接即可全局执行nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/nginx/nginx /usr/local/bin/nginx</span><br></pre></td></tr></table></figure><p>大功告成！</p><h3 id="设置nginx开机自启动"><a href="#设置nginx开机自启动" class="headerlink" title="设置nginx开机自启动"></a>设置nginx开机自启动</h3><p>每次开机我们都要启动nginx，同样巨麻烦，所以可以写一个自启动脚本，使其开机自启动，岂不美滋滋<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/rc.d/init.d</span><br><span class="line">vim nginxserver</span><br></pre></td></tr></table></figure></p><p>这是nginx官网上的自启脚本，将这些粘贴进nginxserver</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># nginx - this script starts and stops the nginx daemon</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig:   - 85 15</span></span><br><span class="line"><span class="comment"># description:  NGINX is an HTTP(S) server, HTTP(S) reverse \</span></span><br><span class="line"><span class="comment">#               proxy and IMAP/POP3 proxy server</span></span><br><span class="line"><span class="comment"># processname: nginx</span></span><br><span class="line"><span class="comment"># config:      /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="comment"># config:      /etc/sysconfig/nginx</span></span><br><span class="line"><span class="comment"># pidfile:     /var/run/nginx.pid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source function library.</span></span><br><span class="line">. /etc/rc.d/init.d/<span class="built_in">functions</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source networking configuration.</span></span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check that networking is up.</span></span><br><span class="line">[ <span class="string">"<span class="variable">$NETWORKING</span>"</span> = <span class="string">"no"</span> ] &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line">nginx=<span class="string">"/usr/local/nginx/nginx"</span></span><br><span class="line">prog=$(basename <span class="variable">$nginx</span>)</span><br><span class="line"></span><br><span class="line">NGINX_CONF_FILE=<span class="string">"/usr/local/nginx/nginx.conf"</span></span><br><span class="line"></span><br><span class="line">[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx</span><br><span class="line"></span><br><span class="line">lockfile=/var/lock/subsys/nginx</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">make_dirs</span></span>() &#123;</span><br><span class="line">   <span class="comment"># make required directories</span></span><br><span class="line">   user=`<span class="variable">$nginx</span> -V 2&gt;&amp;1 | grep <span class="string">"configure arguments:.*--user="</span> | sed <span class="string">'s/[^*]*--user=\([^ ]*\).*/\1/g'</span> -`</span><br><span class="line">   <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$user</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> [ -z <span class="string">"`grep <span class="variable">$user</span> /etc/passwd`"</span> ]; <span class="keyword">then</span></span><br><span class="line">         useradd -M -s /bin/nologin <span class="variable">$user</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      options=`<span class="variable">$nginx</span> -V 2&gt;&amp;1 | grep <span class="string">'configure arguments:'</span>`</span><br><span class="line">      <span class="keyword">for</span> opt <span class="keyword">in</span> <span class="variable">$options</span>; <span class="keyword">do</span></span><br><span class="line">          <span class="keyword">if</span> [ `<span class="built_in">echo</span> <span class="variable">$opt</span> | grep <span class="string">'.*-temp-path'</span>` ]; <span class="keyword">then</span></span><br><span class="line">              value=`<span class="built_in">echo</span> <span class="variable">$opt</span> | cut -d <span class="string">"="</span> -f 2`</span><br><span class="line">              <span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$value</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">                  <span class="comment"># echo "creating" $value</span></span><br><span class="line">                  mkdir -p <span class="variable">$value</span> &amp;&amp; chown -R <span class="variable">$user</span> <span class="variable">$value</span></span><br><span class="line">              <span class="keyword">fi</span></span><br><span class="line">          <span class="keyword">fi</span></span><br><span class="line">       <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">    [ -x <span class="variable">$nginx</span> ] || <span class="built_in">exit</span> 5</span><br><span class="line">    [ -f <span class="variable">$NGINX_CONF_FILE</span> ] || <span class="built_in">exit</span> 6</span><br><span class="line">    make_dirs</span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Starting <span class="variable">$prog</span>: "</span></span><br><span class="line">    daemon <span class="variable">$nginx</span> -c <span class="variable">$NGINX_CONF_FILE</span></span><br><span class="line">    retval=$?</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    [ <span class="variable">$retval</span> -eq 0 ] &amp;&amp; touch <span class="variable">$lockfile</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$retval</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Stopping <span class="variable">$prog</span>: "</span></span><br><span class="line">    killproc <span class="variable">$prog</span> -QUIT</span><br><span class="line">    retval=$?</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    [ <span class="variable">$retval</span> -eq 0 ] &amp;&amp; rm -f <span class="variable">$lockfile</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$retval</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">restart</span></span>() &#123;</span><br><span class="line">    configtest || <span class="built_in">return</span> $?</span><br><span class="line">    stop</span><br><span class="line">    sleep 1</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">reload</span></span>() &#123;</span><br><span class="line">    configtest || <span class="built_in">return</span> $?</span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Reloading <span class="variable">$prog</span>: "</span></span><br><span class="line">    killproc <span class="variable">$nginx</span> -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">force_reload</span></span>() &#123;</span><br><span class="line">    restart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">configtest</span></span>() &#123;</span><br><span class="line">  <span class="variable">$nginx</span> -t -c <span class="variable">$NGINX_CONF_FILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rh_status</span></span>() &#123;</span><br><span class="line">    status <span class="variable">$prog</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rh_status_q</span></span>() &#123;</span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">    start)</span><br><span class="line">        rh_status_q &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line">        <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 0</span><br><span class="line">        <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line">    restart|configtest)</span><br><span class="line">        <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line">    reload)</span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 7</span><br><span class="line">        <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line">    force-reload)</span><br><span class="line">        force_reload</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        rh_status</span><br><span class="line">        ;;</span><br><span class="line">    condrestart|try-restart)</span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> $<span class="string">"Usage: <span class="variable">$0</span> &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;"</span></span><br><span class="line">        <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><ol><li>:wq保存退出</li><li><p>增加脚本的可执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/rc.d/init.d/nginxserver</span><br></pre></td></tr></table></figure></li><li><p>添加脚本到开机自动启动项目中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/rc.d/init.d</span><br><span class="line">chkconfig --add nginxserver</span><br><span class="line">chkconfig nginxserver on</span><br></pre></td></tr></table></figure></li></ol><p>完事！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;老早就想买个服务器，可惜囊中羞涩，一直没有下手，前两天逛阿里云看见个云翼计划，赶紧踩着青春的尾巴买了一年ECS&lt;br&gt;自己没事耍耍也是好的呀&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://promotion.aliyun.com/ntms/act
      
    
    </summary>
    
    
      <category term="linux" scheme="http://www.caopingping.com/tags/linux/"/>
    
      <category term="nginx" scheme="http://www.caopingping.com/tags/nginx/"/>
    
  </entry>
  
</feed>
