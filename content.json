[{"title":"很久之后之深拷贝","date":"2019-05-08T01:49:00.000Z","path":"2019/5/8/很久之后之深拷贝/","text":"五一长假过去了，又该努力工作了呀，先回忆一下深拷贝吧，毕竟这是面试高发笔试题。 变量的存储方式 javascript变量包含两种不同数据类型的值：基本类型和引用类型。 基本类型值指的是简单的数据段，包括es6里面新增的一共是有6种，具体如下：number、string、boolean、null、undefined、symbol。 引用类型值指那些可能由多个值构成的对象，只有一种如下：object。 javascript的变量的存储方式：栈（stack）和堆（heap）。 栈：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址（一个指针） 堆：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。 基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。 引用类型的值是保存在内存中的对象。JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作对象的引用而不是实际的对象。 浅拷贝想当年很长时间都觉得 Object.assign() 就是深拷贝，其实不然。 直接赋值 Object.assign(target,source) …展开运算符 这些方法都不会深拷贝一个对象。直接赋值相当于直接赋值对象的内存引用地址，assign和…都相当于是展开赋值，如果值是基本类型，那么会直接赋值，如果是引用类型，那么会赋值其引用对象的地址。 深拷贝 JSON.parse(JSON.stringify(object))简单直接的方法，但是当对象出现循环引用是会报错，并且无法拷贝Symbol，undefined，function，不可枚举属性 递归赋值。12345678910111213141516171819202122232425function isObj(source)&#123; return (typeof source == 'object' || typeof source == 'function')&amp;&amp; source!null&#125;// 只解决date，reg类型，其他的可以自己添加function deepCopy(obj, hash = new Map()) &#123; let cloneObj let Constructor = obj.constructor switch(Constructor)&#123; case RegExp: cloneObj = new Constructor(obj) break case Date: cloneObj = new Constructor(obj.getTime()) break default: if(hash.has(obj)) return hash.get(obj) // 针对环 cloneObj = new Constructor() hash.set(obj, cloneObj) &#125; for (let key in obj) &#123; cloneObj[key] = isObj(obj[key]) ? deepCopy(obj[key], hash) : obj[key]; &#125; return cloneObj&#125;","tags":[{"name":"JS","slug":"JS","permalink":"http://www.caopingping.com/tags/JS/"}]},{"title":"愚人节之ES6-Proxy","date":"2019-04-02T06:16:00.000Z","path":"2019/4/2/愚人节之ES6-Proxy/","text":"愚人节快乐。复习一下 ES6 的 Proxy 新特性，即将到来的 vue3 也将用 Proxy 代替 Object.defineproperty 来实现数据响应式。 Proxy 是什么Proxy是 ES6 新增的功能，他可以用来自定义对象中的操作（如属性查找，赋值，枚举，函数调用等）。 语法 let p = new Proxy(target, handler); target：用Proxy包装的目标对象，可以是任何类型的对象，包括原生数组，函数，甚至是另一个Proxy. handler: 一个对象，其属性是当执行一个操作时，定义代理行为的函数。 handlerhandler是一个占位符对象（placeholder object），包括了Proxy可以自定义的一些方法。 一共有 13 种可代理操作，每种操作的属性名和触发这种操作的方式列举如下。注意，如果没有定义某种操作，那么这种操作会被转发到目标对象身上。 handler.getPrototypeOf()在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。 handler.setPrototypeOf()在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。 handler.isExtensible()在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。 handler.preventExtensions()在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。 handler.getOwnPropertyDescriptor()在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, “foo”) 时。 handler.defineProperty()在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, “foo”, {}) 时。 handler.has()在判断代理对象是否拥有某个属性时触发该操作，比如在执行 “foo” in proxy 时。 handler.get()在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。 handler.set()在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。 handler.deleteProperty()在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。 handler.ownKeys()在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。 handler.apply()当目标对象为函数，且被调用时触发。 handler.construct()在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。 这些方法的参数基本上都有多个，各有异同，看文档吧。 Examples 基础示例 123456789101112131415let target = &#123;a:1&#125;let handler = &#123; get:function(target,property,receiver)&#123; console.log('target',target) console.log('property',property) console.log('receiver',receiver) return target[property] + '_new' &#125;, set:function(target, property, value, receiver)&#123; target[property] = value return true &#125;&#125;let p = new Proxy(target,handler)console.log(p.a) // 1_new 为每一层都添加监控 1234567891011121314151617181920212223242526let target = &#123; a:1, b:&#123; c:2 &#125;&#125;let handler = &#123; get:function(target,property,receiver)&#123; console.log('target:',target) console.log('property:',property) console.log('receiver:',receiver) if(typeof target[property] === 'object' &amp;&amp; target[property] !== null)&#123; return new Proxy(target[property], handler); &#125;else&#123; return Reflect.get(target, property)+'new' &#125; &#125;, set:function(target, property, value, receiver)&#123; target[property] = value console.log(target[property],'changed') return true &#125;&#125;let p = new Proxy(target,handler)p.b.c = 3","tags":[{"name":"JS","slug":"JS","permalink":"http://www.caopingping.com/tags/JS/"}]},{"title":"JS的继承：原型链","date":"2019-03-22T06:28:00.000Z","path":"2019/3/22/JS的继承：原型链/","text":"撸一遍原型链及其相关的知识点。 prototype和__proto__和constructor prototype是只有函数才有的属性。 __proto__是每个对象都有的属性。 现在我们的起点就是一个创建好的对象，由他开始寻找他的原型链。 他的 __proto__ 指向谁__proto__的指向取决于对象创建的方式。下面这张图是三种常见方式创建对象后，__proto__指向谁。 `__proto__指向谁` 他的 constructor 指向谁所有对象都会从他的原型上继承一个 constructor 属性,并且这个 constructor 等于他的构造函数。 2019-3-21-JS的继承：原型链-2019-3-21-3 即：a.constructor === A.prototype.constructor == A` 什么是原型链对于有基于类的语言经验 (如 Java 或 C++) 的coder来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个class实现。（在 ES2015/ES6 中引入了class关键字，但只是语法糖，JavaScript 仍然是基于原型的）。 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为__proto__）指向它的原型对象（prototype）。该原型对象也有一个自己的私有属性(__proto__) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 几乎所有 JavaScript 中的对象都是位于原型链顶端的Object的实例。 看一张图： 原型链 注意 指向Object.prototype的是 A.prototype.__proto__，而不是A.__proto__，而A.__proto__，下文解析。 Object和Function你可能曾经发现过这么一个现象：12Function instanceof Object; //trueObject instanceof Function; //true 什么鬼？我们先说一下instanceof instanceof究竟是运算什么的对于 object instanceof constructor 简单的来说：instanceof运算符用于 测试 object的原型链中的 任何位置 是否存在constructor的prototype属性 注意：instanceof运算时会递归查找object的原型链，即object.__proto__.__proto__.__proto__.__proto__...直到找到了或者找到顶层为止。 再说Object和Function Function 1234console.log(Function.__proto__) // function() &#123;&#125;console.log(Function.prototype) // function() &#123;&#125;console.log(Function.__proto__===Function.prototype) //true Function的__proto__就是他自己的prototype,并且是一个特殊的匿名函数。 Object 12console.log(Object.__proto__) // function() &#123;&#125;console.log(Object.prototype) // Object的函数们，原型链的终点 我们发现Object.__proto__也是一个匿名函数，那么他与Function的__proto__是同一个吗？ Function与Object 1console.log(Object.__proto__===Function.__proto__) //true 果然是同一个，那么这个特殊的匿名函数又在其中扮演什么角色呢？ 1234let her = Function.__proto__ // 那个匿名函数console.log(her.__proto__) //竟然是Object.prototype?console.log(her.prototype) //当然是undefined的了 Object.prototype没有prototype 关系图 终点还是 Object.prototype 结果根据上面的分析，我们知道了 12345// Object instanceof FunctionObject.__proto__ === Function.prototype// Function instanceof ObjectFunction.__proto__.__proto__ === Object.prototype 还有下面的运算也是应有之理了。 12Object.constructor === Function Function.constructor === Function 一个并没有什么用的小结论 所有构造器的constructor都指向FunctionFunction的prototype指向一个特殊的匿名函数，而这个匿名函数的__proto__指向Object.prototype 所有的结论都会很快的遗忘，只有真正的理解其中的过程才是正理。当然了，过程也是会忘的所以要写下来呀 🐶 最后本文部分图源 感谢博主 FLAG-1","tags":[{"name":"JS","slug":"JS","permalink":"http://www.caopingping.com/tags/JS/"},{"name":"面试","slug":"面试","permalink":"http://www.caopingping.com/tags/面试/"}]},{"title":"知识点整理-JS","date":"2019-03-20T07:07:00.000Z","path":"2019/3/20/知识点整理-JS/","text":"此文是对常见JS基础方面的面试题整理。 继承：原型链与原型链相关的三个概念： prototype(原型)：一个对象，用于实现对象的属性继承。 constructor(构造函数)：一个可以new的函数。只有函数才有prototype。 instance(实例)：构造函数new出来的对象，有一个proto属性，等于其父亲的prototype。三者关系见下一篇文章(FLAG!!) 执行上下文执行上下文，Execution Context，简称EC 内存空间的分配首先了解一下执行上下文的存放JS的基础数据类型有Undefined、Null、Boolean、Number、String，这些都是按值访问，存放在栈内存。其他的Object为引用类型，如数组Array或其他的自定义对象，这些存放在堆内存，其对应的地址引用（指针）放在栈内存。 EC的类型 全局执行上下文 函数执行上下文 eval执行上下文 EC的组成EC由一下三部分组成，可以把它当做一个简单的对象12345testEC = &#123; VO:&#123;&#125;, scopeChain: &#123;&#125;, this: &#123;&#125;&#125; VO：变量对象，包括当前EC中创建的所有变量和函数声明(不包含函数表达式) scopeChain：作用域链，是由当前内存中各个变量对象VO串起来的单向链表，每入栈执行一个function，其对应的VO就添加到作用域链的头部，前一个VO能自由访问到下一个VO上的变量，反过来就不行。 作用域链可以理解为一组对象列表，包含父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。这个对象由两部分构成 [[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO AO: 自身活动对象 this：this的指向，是在执行上下文被创建时确定的，也就是说this是在函数执行时确定的。 执行先看一段代码1234567891011var color = 'blue';function changeColor() &#123; var anotherColor = 'red'; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor(); 当代码执行时，首先创建全局执行上下文（global EC）并入栈，每进入一个function，就做一次入栈操作，向栈顶压入一个属于该function的新的EC。若function中又调用了另一个function，则再执行一次入栈…依次执行完再依次出栈，回到全局EC。全局EC一定是在栈底，在浏览器关闭后出栈。 执行上下文图解 本节图片来源： 感谢博主 作用域作用域其实可理解为该上下文中声明的变量的作用范围。可分为 全局作用局、局部作用域（函数作用域）。ES6引入let后，块级作用域开始起作用。 作用域会声明提前：一个声明在其作用域内都是可见的，函数提升优于变量提升。 函数的父级作用域，是函数定义的时候的父级作用域，不是函数执行的时候的父级作用域，即函数在哪定义，父级作用域就在什么地方123456789var a = 2;function test()&#123; console.log(a);&#125;function b ()&#123; var a =3; test();&#125;b(); //结果为2而不是3 闭包闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。 经典问题那个例子：12345for(var i= 0;i&lt;10;i++)&#123; clickObj[i].onclick = function()&#123; console.log(i); &#125;&#125; 解析：当for循环完成是，声明了i个function，他们的父级作用域都是全局作用域。函数体内的 i 并没有被赋值，而是等待click事件，当事件触发时，函数运行，在自己的作用域内没有找到 i ,于是向自己的父级作用域寻找 i,于是找到 i=9。 解决：生成闭包,保存父级的作用域。1234567for(var i= 0;i&lt;10;i++)&#123; (function(ind)&#123; clickObj[ind].onclick = function()&#123; console.log(ind); &#125; &#125;)(i)&#125; script引入方式 HTML静态 &lt;script&gt; 引入 JS动态插入 &lt;script defer&gt; &lt;script async&gt; 最稳妥的做法还是把&lt;script&gt;写在&lt;body&gt;底部，没有兼容性问题，没有白屏问题，没有执行顺序问题，高枕无忧，不要搞什么defer和async的花啦~ 之间的区别一图胜千言 区别图 写在最后此文持续更新！！！","tags":[{"name":"JS","slug":"JS","permalink":"http://www.caopingping.com/tags/JS/"},{"name":"面试","slug":"面试","permalink":"http://www.caopingping.com/tags/面试/"}]},{"title":"知识点整理-CSS","date":"2019-03-19T07:13:00.000Z","path":"2019/3/19/知识点整理-CSS/","text":"一看离上次写文已经三个月了竟然，果然坚持是最难的呀，过完年忙碌了两个月，该复习一下了，说不定什么时候找工作呢。 盒模型当对文档进行布局（lay out）的时候，浏览器渲染引擎会根据CSS基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子。 每个盒子由四部分组成：内容content，内边界paddingm，边框border和外边界margin。而box-sizing属性定义了浏览器该如何计算盒子的总宽度和总高度。 content-box 标准盒模型，width与height只包含content的宽高。 border-box IE盒模型，本人布局最爱，width和height包含content，padding，border，不包括margin。 padding-box width 和 height 属性包括内容和内边距，但是不包括边框和外边距。只有Firefox实现了这个值，它在Firefox 50中被删除。 margin-box 无浏览器实现 BFC块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 BFC包含创建它的元素内部的所有内容。 触发条件 根元素 浮动 float != none 定位 position == absolute|fixed dispaly display == inline-block|table overflow overflow != visible 表现 在一个BFC中，垂直方向上，盒子是从包含块顶部开始一个一个布局的，两个相邻的盒子的垂直距离是有margin属性决定的，两个相邻的块级盒子的垂直外边距会产生塌陷。 在一个BFC中，水平方向上，每个盒子的左边缘都会接触包含块的左边缘（从右向左的格式则相反），除非出现浮动元素和其他元素相互作用的情况 经典案例 应用 消除垂直外边距塌陷。 可以包含浮动元素，解决高度塌陷。 创建自适应布局 参考经典案例 层叠上下文一图说明 层叠上下文 link 与 @import 的区别 从属关系区别@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。 加载顺序区别加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。 兼容性区别@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。 DOM可控性区别可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。 写在后边此文会持久更新，在此立下FLAG！！","tags":[{"name":"面试","slug":"面试","permalink":"http://www.caopingping.com/tags/面试/"},{"name":"CSS","slug":"CSS","permalink":"http://www.caopingping.com/tags/CSS/"}]},{"title":"图片上传方案详解","date":"2019-01-03T08:56:00.000Z","path":"2019/1/3/图片上传方案详解/","text":"以往用到图片上传功能都是直接使用现成的插件，今天把其中用到的知识点整理一下。 知识点字典 input 标签之 file 类型 FileReader 对象：读取文件 FileReader.readAsDataURL()：将读取的文件转换为 base64 编码的字符串 FormData 对象 使用 axios 上传 input 标签之 file 类型当设置 input 标签 type 为 file 时，input 表现性状为上传文件样式 默认样式 file-input 有如下属性： accept指定选择文件类型的范围。默认为所有文件类型图片为 accept=”image/*“文件类型取值见MDN capture当文件类型为图片或视频且在移动端时，此属性才有意义。 capture = ‘user’ 调用前置摄像头 capture = ‘environment’ 调用后置摄像头 不设置则为用户自己选择 multiple一个 Boolean 值，如果存在，则表示用户可以选择多个文件 files返回一个 FileList，列出每个所选文件对象。除非 multiple 指定了属性，否则此列表只有一个成员。主要用于 JS 操作。 12&lt;!-- html --&gt;&lt;input type=\"file\" multiple id=\"imgLocal\" accept=\"image/*\" /&gt; 123456// jslet inp = document.querySelector('#imgLocal')inp.onchange = function(e) &#123; let fileList = document.querySelector('#imgLocal').files console.log(fileList) //files&#125; FileReader 对象我们用 FileReader 对象实现图片预览功能。 FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 构造函数new FileReader() 返回一个新构造的 FileReader。 属性 FileReader.readyState表示 FileReader 状态的数字，取值如下 0：EMPTY/还没有加载任何数据 1：LOADING/数据正在被加载 2：DONE/已完成全部的读取请求 FileReader.result文件的内容。该属性仅在读取操作完成后才有效。 FileReader.error 事件及方法我们主要是用 FileReader.onload 事件及 FileReader.readAsDataURL() 方法，其他见MDN FileReader.onload处理 load 事件。该事件在读取操作完成时触发 FileReader.readAsDataURL()开始读取指定的 Blob 中的内容。一旦完成，result 属性中将包含一个 data: URL 格式的字符串以表示所读取文件的内容。 123456789//继续使用上文的fileListlet file = fileList[0]const fileReader = new FileReader()fileReader.readAsDataURL(file) //读取图片fileReader.addEventListener('load', function() &#123; // 读取完成 let res = fileReader.result // res是base64格式的图片&#125;) 我们将 DOM 上 img 的 src 设为读取的结果即可实现预览功能。 FormData 对象FormData 对象的使用： 用一些键值对来模拟一系列表单控件：即把 form 中所有表单元素的 name 与 value 组装成一个 queryString 异步上传二进制文件。 构造函数new FormData() 返回一个新构造的 FormData。 方法FormData 方法有很多。我们这里只用了她的 append()方法 formData.append(name, value, filename) name:属性名 value:属性值，在我们这里则指 file 数据 filename:当第二个参数为 file 或 blob 时，告诉服务器的文件名。Blob 对象的默认文件名是“blob”。File 对象的默认文件名 是文件的文件名。 123// 继续使用上文的fileconst formDate = new FormData()formDate.append('userPicture', file, '1.jpg') 使用 axios 上传主要是设置 header 中的 Content-Type 直接上代码 1234567891011121314//继续使用上文的formDatelet config = &#123; headers: &#123; 'Content-Type': 'multipart/form-data' &#125;&#125;axios .post('serverUrl', formDate, config) .then(res =&gt; &#123; console.log(res) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) axios 亦可 使用onUploadProgress监听上传进度，不再赘述。 其他其他还有直接form表单提交文件等方式，可能不太自由。诸位有兴趣的可以看一下。","tags":[{"name":"JS","slug":"JS","permalink":"http://www.caopingping.com/tags/JS/"}]},{"title":"Array和Object的迭代","date":"2019-01-02T10:31:00.000Z","path":"2019/1/2/Array和Object的迭代/","text":"这篇文章是为了记录以下几个比较容易记忆混乱的方法 for…in (hasOwnProperty) for…of Object.keys() Object.getOwnPropertyNames() for…in使用for..in循环时，返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例（实例+原型中的可枚举属性） 遍历对象for..in操作的主要目的就是遍历对象的属性，如果只需要获取对象自身的实例属性，可以使用hasOwnProperty()进行过滤。12345678910111213141516171819202122function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;// 实例化let cpp = new Person('cpp', 25);for (let prop in cpp) &#123; console.log(prop); // name age getName&#125;let hasOwn = Object.prototype.hasOwnProperty;for (let prop2 in cpp) &#123; if (hasOwn.call(cpp, prop2)) &#123; console.log(prop2); // name age &#125;&#125; 遍历数组for…in主要用用于遍历对象，但同样也可以遍历数组1234let arr = [1,2,3,4,5]for(let i in arr)&#123; console.log(`索引$&#123;i&#125;：$&#123;arr[i]&#125;`)&#125; 但是为什么大家都说不推荐使用for…in来遍历数组呢，总结了一下一共有三个理由 如果扩展了原生的Array，那么扩展的属性会被for..in输出 for..in 会遍历原型中的属性，所以，无论是遍历数组还是对象，如果在原型中添加的属性的enumerable为true,都会被for..in 遍历出来 可以使用Object.defineProperty添加，并设置 enumerable为false 对于不存在的数组项的处理 对于数组来讲，我们知道如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined值。 12345678910111213let colors = ['red','yellow','blue']colors.length = 5 colors.push('orange')for(let i in colors)&#123; console.log(colors[i])&#125;// 输出为 'red' 'yellow' 'blue' 'orange'for(let i = 0;i&lt;colors.length;i++)&#123; console.log(colors[i])&#125;// 输出为 'red' 'yellow' 'blue' undefined undefined 'orange' 可见for..in 循环数组不会枚举不存在的项，但这些项在内存中是真实存在的，我们可以删除这些项，也可以给他们赋值。 遍历顺序 数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同。不能保证for … in将以任何特定的顺序返回索引。for … in循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些。 因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。 for…of 与 for…in 的区别ES6新增for…offor…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 无论是for…in还是for…of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。 for…in 语句以原始插入顺序迭代对象的可枚举属性。 for…of 语句遍历可迭代对象定义要迭代的数据。 12345678910111213141516171819Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;let iterable = [3, 5, 7];iterable.foo = 'hello';for (let i in iterable) &#123; console.log(i); // 0, 1, 2, \"foo\", \"arrCustom\", \"objCustom\"&#125;for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // 0, 1, 2, \"foo\" &#125;&#125;for (let i of iterable) &#123; console.log(i); // 3, 5, 7&#125; for…of 是根据 要迭代的数据的迭代器进行遍历的迭代器可以自定义需要定义要迭代数据的 Symbol.iterator Object没有默认的迭代器，所以默认for…of不能用于Object Object.keys()Object.keys()用于获取对象自身所有的可枚举的，但不包括原型中的属性，然后返回一个由属性名组成的数组。一个例子理解:12345678910111213141516171819// 遍历数组let colors = ['red','yellow','blue']colors.length = 5 colors.push('orange')Array.prototype.demo = function () &#123;&#125;;Object.keys(colors); // [\"0\", \"1\", \"2\", \"10\"]// 遍历对象function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.demo = function() &#123;&#125;var cpp = new Person('cpp', 25);Object.keys(cpp); // [\"name\", \"age\"] Object.getOwnPropertyNames()Object.getOwnPropertyNames()方法返回对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组，但不会获取原型链上的属性。 1234567891011121314151617181920function A(a,aa) &#123; this.a = a; this.getA = function() &#123; return this.a; &#125;&#125;// 原型方法A.prototype.aaa = function () &#123;&#125;;var B = new A('b', 'bb');//自身方法B.myMethodA = function() &#123;&#125;;// 不可枚举方法Object.defineProperty(B, 'myMethodB', &#123; enumerable: false, value: function() &#123;&#125;&#125;);Object.getOwnPropertyNames(B); //结果 [\"a\", \"getA\", \"myMethodA\", \"myMethodB\"] 只获取自身不可枚举属性：使用 Object.getOwnPropertyNames() 获得所有自身属性，通过 Object.keys() 获得自身可枚举属性，通过filter函数筛选即可。 总结 名称 适用 描述 for in 数组 对象 实例+原型 的可枚举属性 for of 有迭代器的可迭代对象（Array,Map,Set等） 返回属性值 Object.keys() 数组 对象 获取对象自身所有的可枚举的属性 Object.getOwnPropertyNames() 数组 对象 获取对象的所有自身属性的属性名，包括不可枚举属性但不包括Symbol值作为名称的属性","tags":[{"name":"JS","slug":"JS","permalink":"http://www.caopingping.com/tags/JS/"}]},{"title":"浏览器缓存整理","date":"2018-12-29T06:55:00.000Z","path":"2018/12/29/浏览器缓存整理/","text":"对浏览器缓存这一块一直是乱哄哄的状态，今天终于有时间整理一下，写下这篇笔记，以供日后查阅。 缓存概述良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度通常浏览器缓存策略分为两种：强缓存和协商缓存 基本流程 浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。 如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源 如果前面两者都没有命中，直接从服务器加载资源 相同点如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据； 不同点强缓存不发请求到服务器，协商缓存会发请求到服务器。 强缓存强缓存通过Expires和Cache-Control两种响应头实现 ExpiresExpires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效 1Expires: Sat, 29 Sep 2018 14:20:00 GMT Cache-ControlCache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间1Cache-Control: max-age=315360000 Cache-Control在request和response中都可以使用 在请求中使用Cache-Control 时，它可选的值有： Cache-Control在请求头中的取值 在响应中使用Cache-Control 时，它可选的值有： Cache-Control在响应头中的取值 强缓存流程图 强缓存流程图 协商缓存当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的 Last-Modified，If-Modified-SinceLast-Modified 表示请求来的文件的最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 ETag、If-None-MatchEtag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的 If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来 ETag的优先级比Last-Modified更高 大致流程 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个Last-Modified/ETag。 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。 感觉两个功能重复了？ETag对Last-Modified的补充首先Last-Modified在http/1.0中被提出，而在http/1.1中提出的ETag则是为了解决Last-Modified无法解决的一些问题 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间。 Last-Modified对ETag的补充一些图片等静态文件的修改，如果每次扫描内容生成 ETag 来比较，显然要比直接比较修改时间慢很多 小结所以说两者并不是互斥，而是相辅相成的关系，既可以单独使用，又可以同时使用。 同时传入服务器时，服务器可以根据自己的缓存机制的需要，选择ETag或者是Last-Modified来做缓存判断的依据，甚至可以两个同时参考。 如何使用 协商缓存需要配合强缓存使用，如果不启用强缓存的话，协商缓存根本没有意义 大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】 Apache对于静态内容默认会返回Last-modified和ETag. Nginx只会返回Last-modified(可配置etag on开启). 但是下面的场景需要注意： 分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败； 分布式系统尽量关闭掉ETag（每台机器生成的ETag都会不一样） 整体流程图 浏览器缓存整理 参考https://github.com/amandakelake/blog/issues/41https://blog.csdn.net/u012375924/article/details/82806617https://segmentfault.com/q/1010000004200644baidu and google","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.caopingping.com/tags/HTTP/"}]},{"title":"JavaScript之数据属性和访问器属性","date":"2018-12-28T08:25:00.000Z","path":"2018/12/28/JavaScript之数据属性和访问器属性/","text":"在javaScript中，对象的属性分为两种类型：数据属性和访问器属性。 数据属性数据属性包含的是一个数据值的位置，在这可以对数据值进行读写。 数据属性包含四个特性，分别是： configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为true enumerable:表示能否通过for-in循环返回属性 writable：表示能否修改属性的值 value：包含该属性的数据值。默认为undefined 访问器属性访问器属性不包含数据值，包含的是一对get和set方法，在读写访问器属性时，就是通过这两个方法来进行操作处理的。 访问器属性包含的四个特性： configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为false enumerable:表示能否通过for-in循环返回属性,默认为false Get：在读取属性时调用的函数,默认值为undefined Set：在写入属性时调用的函数,默认值为undefined 属性的读取与修改 对象的属性通过 Object.getOwnPropertyDescriptor() 获取 对象的属性通过 Object.defineProperty() 修改 数据属性和访问器属性是同级别的关系，只是由于功能不同把它们分成两派，按照它们所谓的 “特征值” 定义这个属性的性质。访问器属性只是因为它带有可以访问对象内其它属性的功能（通过 getter、setter 函数），并经过一些处理从而实现 “设置一个属性的值会导致其他属性发生变化”的效果。 如果一个对象属性同时有(value或writable)和(get或set)关键字，将会产生一个异常 如果只指定get方法,不指定set方法，那么这个属性是只读的，反之则是只写的 12345678910111213141516171819202122232425262728293031323334353637383940let obj = &#123;a:1,_b:2&#125;Object.getOwnPropertyDescriptor(obj,'a') /* &#123; value: 1, writable: true, enumerable: true, configurable: true &#125; *///修改数据属性Object.defineProperty(obj,'a',&#123; value: 100, writable: false, enumerable: false, configurable: true&#125;)Object.getOwnPropertyDescriptor(obj,'a') /* &#123; value: 100, writable: false, enumerable: false, configurable: true &#125; */// 修改访问器属性Object.defineProperty(obj,'b',&#123; get()&#123; return this._b &#125;, set(newVal)&#123; this._b = this._b + newVal &#125;,&#125;)obj.b = 5console.log(obj.b) // 7","tags":[{"name":"JS","slug":"JS","permalink":"http://www.caopingping.com/tags/JS/"}]},{"title":"HTTP系统学习","date":"2018-12-27T07:16:00.000Z","path":"2018/12/27/HTTP系统学习/","text":"虽然日常都离不开HTTP，平时HTTP学习的很多，但是都很零碎，今天就把HTTP系统的整理一遍，形成一个完整的知识闭环。以下章节排序不是HTTP时序。 http简介1.是什么HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 HTTP是一个基于TCP/IP通信协议来传递数据。 2.工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP默认端口号为80。 http有三个特点 HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 但是随着时间的推移，网页越来越复杂，传统的无连接无状态就变得很低效，所以对针对无连接，Keep-Alive被提了出来，cookie,session等保持HTTP连接的技术也应运而生 3.各版本HTTP HTTP/0.9只有一个命令GET没有HEADER等描述数据的信息服务器发送完毕，就关闭TCP连接 HTTP/1.0增加了很多命令增加status code和header多字符集支持、多部分发送、权限、缓存等 HTTP/1.1持久连接pipeline增加host和其他一些命令 HTTP2所有数据以二进制传输同一个连接里面发送多个请求不再需要按照顺序来头信息压缩以及推送等提高效率的功能 目前使用最广泛的还是HTTP1.1 4.HTTPSHTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 我们这里只简单提一下HTTPS，主要学习HTTP HTTP报文HTTP请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 请求报文 1.请求行请求行分为三部分，请求方法，请求地址，协议版本 请求方法HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。 请求地址URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。 组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 端口和路径有时可以省略（HTTP默认端口号是80） GET请求会带参数 协议版本协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1 2.请求头部请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。 Headers 解释 实例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: gzip Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Host 指定请求的服务器的域名和端口号 Host: www.caopingping.com Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection:keep-alive referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.caopingping.com/about User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) 请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。 3.请求数据请求数据可选，比如GET请求没有请求数据 下面是一个POST请求的请求报文 POST /index.php HTTP/1.1 请求行 Host: localhost 请求头 User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language: zh-cn,zh;q=0.5 Accept-Encoding: gzip, deflate Connection: keep-alive Referer: http://localhost/ Content-Length：25 Content-Type：application/x-www-form-urlencoded 空行 username=aa&amp;password=1234 请求数据 HTTP响应报文 响应报文 HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。 1.状态行由3部分组成，分别为：协议版本，状态码，状态码描述。 其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。 状态码状态代码为3位数字。1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。 下面列举几个常见的： 状态码 状态码英文名称 描述 200 OK 请求成功。一般用于GET与POST请求 302 Found 临时移动。与301类似。但资源只是临时被移动 400 Bad Request 客户端请求的语法错误，服务器无法理解 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页） 500 Internal Server Error 服务器内部错误，无法完成请求 2.响应头部与请求头部类似，为响应报文添加了一些附加信息常见响应头部如下： Header 解释 示例 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT 2.响应数据用于存放需要返回给客户端的数据信息。 HTTP请求与响应的过程TCP/IP协议模型TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。 HTTP协议就是基于TCP/IP协议模型来传输信息的。 下面这张图可以清楚的看明白TCP/IP模型的角度下HTTP请求与响应的过程 TCP/IP模型的角度下HTTP请求与响应 TCP三次握手TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 TCP三次握手 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。 现在就可以进行数据请求了，也就是上文的请求与响应。 TCP四次挥手 TCP四次挥手 第一次分手：主机1（可以是客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次分手 TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 总结一图以蔽之 HTTP流程总结 参考https://www.jianshu.com/p/c1d6a294d3c0https://blog.csdn.net/qq_33616529/article/details/78288883百度Google","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.caopingping.com/tags/HTTP/"}]},{"title":"linux下git免登陆设置","date":"2018-11-16T07:51:00.000Z","path":"2018/11/16/linux下git免登陆设置/","text":"使用Git的时候，每次操作都得输入用户名密码，神烦啊！网上找了资料很快就弄好了，做个记录，以备不时之需。 1.创建.git-credentials文件12cd /rootvim .git-credentials 在文件中写入 https://{username}:{password}@github.com 即你的用户名密码，保存退出。 2.在终端下执行1git config --global credential.helper store 3.查看是否成功1cat /root/.gitconfig 如果多了一项： 12[credential]helper = store 设置成功。下次就不用再输入用户名密码了。 美滋滋。","tags":[{"name":"git","slug":"git","permalink":"http://www.caopingping.com/tags/git/"}]},{"title":"hexo博客搭建过程记录","date":"2018-11-15T04:50:00.000Z","path":"2018/11/15/hexo博客搭建过程记录/","text":"以前一直用的github.io搭的自己的博客，总觉得差点意思，还是自己整个服务器吧，以下是在阿里云centos7下完成的，记录一下。 Node环境与Git安装hexo基于nodeJs，所以首先要安装node 安装1234cd /usr/local/src/wget https://nodejs.org/dist/v10.13.0/node-v10.13.0-linux-x64.tar.xztar -xvf node-v10.13.0-linux-x64.tar.xzmv node-v10.13.0-linux-x64 nodejs 可以到https://nodejs.org/en/download/下载需要的node版本，如果下载sourceCode源码版本，需要自己编译很长时间，不推荐，我下载的Linux Binaries (x64) 查看 nodejs文件夹 下有是否有node 和npm文件，如果没有重新下载安装。 建立软链接将npm和node命令转为全局命令 12ln -s /usr/local/src/nodejs/bin/npm /usr/local/bin/npmln -s /usr/local/src/nodejs/bin/node /usr/local/bin/node 检验node是否已全局可用1node -v cnpm如果想使用cnpm 可以全局安装后，建立软链接，同2，不再赘述 git安装12yum -y install gitgit --version hexo安装全局安装hexo1npm install -g hexo-cli 初始化hexo项目进入hexo项目文件夹，我的是在/home/apps/ 1234cd /home/apps/hexo init hexoblogcd hexoblognpm i 安装完成后目录如下 node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 配置 网站的初始配置都在_config.yml中，我们可以在其中修改大部分配置。 具体配置见 hexo官网 启动安装完成后，hollow world 终于可以打开了 123cd /home/apps/hexobloghexo shexo g -d 现在打开服务器ip 4000 端口即可看到Hellow world 页面啦 2018-11-15-hexo博客搭建过程记录-20181115 主题的使用hexo安装完成后切换主题极其简单，我现在用的是Material Design 风格的Hexo主题 indigo ,更多主题可以在 官网 查看，选择你心仪的主题即可，亦可自己开发DIY。 别忘了给作者start哦 12cd /home/apps/hexoblog/git clone https://github.com/yscoder/hexo-theme-indigo.git themes/indigo 然后将_config.yml中 theme 选项设为 indigo 即可 此主题需要安装依赖，具体步骤查看作者文档 文档 hexo管理工具如果我们每次写完都要把文件传到服务器，再 hexo g -d,那岂不是很麻烦，当然也可以接受，不过hexo-admin可以更方便的管理你的博文，是你在随便一个浏览器即可写作，美滋滋 看这里即可，使用极其简单 hexo-admin ##结束 如果不出意外，现在你已经可以写文章了，具体的文章写作和加载，请直接看官网吧。有啥意外可以问我😀😀😀","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.caopingping.com/tags/hexo/"},{"name":"node","slug":"node","permalink":"http://www.caopingping.com/tags/node/"}]},{"title":"centos下nginx的安装与自启","date":"2018-11-14T07:49:00.000Z","path":"2018/11/14/centos下nginx的安装与自启/","text":"老早就想买个服务器，可惜囊中羞涩，一直没有下手，前两天逛阿里云看见个云翼计划，赶紧踩着青春的尾巴买了一年ECS自己没事耍耍也是好的呀 阿里云翼计划 废话不多说，这就开始 准备工作 服务器一台 我用的是阿里云centos7 xshell 其它亦可 linux基本操作 nginx和配置我们一会还要安装node，node自己本身可以作为服务器进行驱动，但是node本身对文件的处理能力并不是很好，所以当我们的生产环境中应尽量使用nginx来处理静态的资源以及反向代理，同时也解决了node分布式以及负载均衡的相关问题。 安装 首先安装make gcc之类的东西，编译用 12yum -y install automake autoconf libtool makeyum install gcc gcc-c++ 选择nginx安装目录，我选的是 /usr/local/src 1cd /usr/local/src 一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。 123456wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.42.tar.gztar -zxvf pcre-8.42.tar.gzcd pcre-8.42./configuremakemake install 可以在ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/选择最新版本pcre 123456wget http://zlib.net/zlib-1.2.11.tar.gztar -zxvf zlib-1.2.11.tar.gzcd zlib-1.2.11./configuremakemake install 可以在http://zlib.net/选择最新版本zlib 安装ssl网络通信安全，功能丰富且自包含的开源安全工具箱12wget https://www.openssl.org/source/openssl-1.1.1.tar.gztar -zxvf openssl-1.1.1.tar.gz 可以在https://www.openssl.org/source/选择最新版本openssl 安装nginx Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：1234567891011121314wget http://nginx.org/download/nginx-1.4.2.tar.gztar -zxvf nginx-1.4.2.tar.gzcd nginx-1.4.2 ./configure --sbin-path=/usr/local/nginx/nginx \\--conf-path=/usr/local/nginx/nginx.conf \\--pid-path=/usr/local/nginx/nginx.pid \\--with-http_ssl_module \\--with-pcre=/usr/src/local/pcre-8.42 \\--with-zlib=/usr/src/local/zlib-1.2.11 \\--with-openssl=/usr/src/local/openssl-1.1.1 makemake install –with-pcre=/usr/src/local/pcre-8.42 指的是pcre-8.42 的源码路径。–with-zlib=/usr/src/local/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。 安装完成安装成功后 /usr/local/nginx 目录下如下123456789101112131415161718192021222324drwx------ 2 nobody root 4096 Nov 2 10:16 client_body_temp-rw-r--r-- 1 root root 1034 Nov 1 18:43 fastcgi.conf-rw-r--r-- 1 root root 1034 Nov 1 18:43 fastcgi.conf.default-rw-r--r-- 1 root root 964 Nov 1 18:43 fastcgi_params-rw-r--r-- 1 root root 964 Nov 1 18:43 fastcgi_params.defaultdrwx------ 2 nobody root 4096 Nov 2 10:16 fastcgi_tempdrwxr-xr-x 2 root root 4096 Nov 2 11:11 html-rw-r--r-- 1 root root 2837 Nov 1 18:43 koi-utf-rw-r--r-- 1 root root 2223 Nov 1 18:43 koi-windrwxr-xr-x 2 root root 4096 Nov 2 10:16 logs-rw-r--r-- 1 root root 3463 Nov 1 18:43 mime.types-rw-r--r-- 1 root root 3463 Nov 1 18:43 mime.types.default-rwxr-xr-x 1 root root 7177456 Nov 1 18:43 nginx-rw-r--r-- 1 root root 3937 Nov 13 16:14 nginx.conf-rw-r--r-- 1 root root 2685 Nov 1 18:43 nginx.conf.default-rw-r--r-- 1 root root 5 Nov 12 10:02 nginx.piddrwx------ 12 nobody root 4096 Nov 13 15:29 proxy_temp-rw-r--r-- 1 root root 596 Nov 1 18:43 scgi_params-rw-r--r-- 1 root root 596 Nov 1 18:43 scgi_params.defaultdrwx------ 2 nobody root 4096 Nov 2 10:16 scgi_temp-rw-r--r-- 1 root root 623 Nov 1 18:43 uwsgi_params-rw-r--r-- 1 root root 623 Nov 1 18:43 uwsgi_params.defaultdrwx------ 2 nobody root 4096 Nov 2 10:16 uwsgi_temp-rw-r--r-- 1 root root 3610 Nov 1 18:43 win-utf 启动12cd /usr/local/nginx/./nginx 现在打开浏览器，输入此机器IP即可看到 Welcome To Nginx 安装成功！ 将nginx加入可执行程序目录竟然每次操作nginx都要进入/usr/local/nginx/好麻烦有木有没关系 软链接来帮你/usr/local/bin目录是给用户放置自己的可执行程序的地方,我们只需在这里建立nginx的软链接即可全局执行nginx 1ln -s /usr/local/nginx/nginx /usr/local/bin/nginx 大功告成！ 设置nginx开机自启动每次开机我们都要启动nginx，同样巨麻烦，所以可以写一个自启动脚本，使其开机自启动，岂不美滋滋12cd /etc/rc.d/init.dvim nginxserver 这是nginx官网上的自启脚本，将这些粘贴进nginxserver 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \\# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ \"$NETWORKING\" = \"no\" ] &amp;&amp; exit 0nginx=\"/usr/local/nginx/nginx\"prog=$(basename $nginx)NGINX_CONF_FILE=\"/usr/local/nginx/nginx.conf\"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | grep \"configure arguments:.*--user=\" | sed 's/[^*]*--user=\\([^ ]*\\).*/\\1/g' -` if [ -n \"$user\" ]; then if [ -z \"`grep $user /etc/passwd`\" ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d \"=\" -f 2` if [ ! -d \"$value\" ]; then # echo \"creating\" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done fi&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $\"Starting $prog: \" daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $\"Stopping $prog: \" killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $\"Reloading $prog: \" killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case \"$1\" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $\"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;\" exit 2esac :wq保存退出 增加脚本的可执行权限 1chmod +x /etc/rc.d/init.d/nginxserver 添加脚本到开机自动启动项目中 123cd /etc/rc.d/init.dchkconfig --add nginxserverchkconfig nginxserver on 完事！","tags":[{"name":"linux","slug":"linux","permalink":"http://www.caopingping.com/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"http://www.caopingping.com/tags/nginx/"}]}]