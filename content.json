[{"title":"HTTP系统学习","date":"2018-12-27T07:16:00.000Z","path":"2018/12/27/HTTP系统学习/","text":"虽然日常都离不开HTTP，平时HTTP学习的很多，但是都很零碎，今天就把HTTP系统的整理一遍，形成一个完整的知识闭环。以下章节排序不是HTTP时序。 http简介1.是什么HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 HTTP是一个基于TCP/IP通信协议来传递数据。 2.工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP默认端口号为80。 http有三个特点 HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 但是随着时间的推移，网页越来越复杂，传统的无连接无状态就变得很低效，所以对针对无连接，Keep-Alive被提了出来，cookie,session等保持HTTP连接的技术也应运而生 3.各版本HTTP HTTP/0.9只有一个命令GET没有HEADER等描述数据的信息服务器发送完毕，就关闭TCP连接 HTTP/1.0增加了很多命令增加status code和header多字符集支持、多部分发送、权限、缓存等 HTTP/1.1持久连接pipeline增加host和其他一些命令 HTTP2所有数据以二进制传输同一个连接里面发送多个请求不再需要按照顺序来头信息压缩以及推送等提高效率的功能 目前使用最广泛的还是HTTP1.1 4.HTTPSHTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 我们这里只简单提一下HTTPS，主要学习HTTP HTTP报文HTTP请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 请求报文 1.请求行请求行分为三部分，请求方法，请求地址，协议版本 请求方法HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。 请求地址URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。 组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 端口和路径有时可以省略（HTTP默认端口号是80） GET请求会带参数 协议版本协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1 2.请求头部请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。 Headers 解释 实例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: gzip Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Host 指定请求的服务器的域名和端口号 Host: www.caopingping.com Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection:keep-alive referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.caopingping.com/about User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) 请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。 3.请求数据请求数据可选，比如GET请求没有请求数据 下面是一个POST请求的请求报文 POST /index.php HTTP/1.1 请求行 Host: localhost 请求头 User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language: zh-cn,zh;q=0.5 Accept-Encoding: gzip, deflate Connection: keep-alive Referer: http://localhost/ Content-Length：25 Content-Type：application/x-www-form-urlencoded 空行 username=aa&amp;password=1234 请求数据 HTTP响应报文 响应报文 HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。 1.状态行由3部分组成，分别为：协议版本，状态码，状态码描述。 其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。 状态码状态代码为3位数字。1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。 下面列举几个常见的： 状态码 状态码英文名称 描述 200 OK 请求成功。一般用于GET与POST请求 302 Found 临时移动。与301类似。但资源只是临时被移动 400 Bad Request 客户端请求的语法错误，服务器无法理解 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页） 500 Internal Server Error 服务器内部错误，无法完成请求 2.响应头部与请求头部类似，为响应报文添加了一些附加信息常见响应头部如下： Header 解释 示例 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT 2.响应数据用于存放需要返回给客户端的数据信息。 HTTP请求与响应的过程TCP/IP协议模型TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。 HTTP协议就是基于TCP/IP协议模型来传输信息的。 下面这张图可以清楚的看明白TCP/IP模型的角度下HTTP请求与响应的过程 TCP/IP模型的角度下HTTP请求与响应 TCP三次握手TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 TCP三次握手 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。 现在就可以进行数据请求了，也就是上文的请求与响应。 TCP四次挥手 TCP四次挥手 第一次分手：主机1（可以是客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次分手 TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 总结一图以蔽之 HTTP流程总结 参考https://www.jianshu.com/p/c1d6a294d3c0https://blog.csdn.net/qq_33616529/article/details/78288883百度Google","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.caopingping.com/tags/HTTP/"}]},{"title":"linux下git免登陆设置","date":"2018-11-16T07:51:00.000Z","path":"2018/11/16/linux下git免登陆设置/","text":"使用Git的时候，每次操作都得输入用户名密码，神烦啊！网上找了资料很快就弄好了，做个记录，以备不时之需。 1.创建.git-credentials文件12cd /rootvim .git-credentials 在文件中写入 https://{username}:{password}@github.com 即你的用户名密码，保存退出。 2.在终端下执行1git config --global credential.helper store 3.查看是否成功1cat /root/.gitconfig 如果多了一项： 12[credential]helper = store 设置成功。下次就不用再输入用户名密码了。 美滋滋。","tags":[{"name":"git","slug":"git","permalink":"http://www.caopingping.com/tags/git/"}]},{"title":"hexo博客搭建过程记录","date":"2018-11-15T04:50:00.000Z","path":"2018/11/15/hexo博客搭建过程记录/","text":"以前一直用的github.io搭的自己的博客，总觉得差点意思，还是自己整个服务器吧，以下是在阿里云centos7下完成的，记录一下。 Node环境与Git安装hexo基于nodeJs，所以首先要安装node 安装1234cd /usr/local/src/wget https://nodejs.org/dist/v10.13.0/node-v10.13.0-linux-x64.tar.xztar -xvf node-v10.13.0-linux-x64.tar.xzmv node-v10.13.0-linux-x64 nodejs 可以到https://nodejs.org/en/download/下载需要的node版本，如果下载sourceCode源码版本，需要自己编译很长时间，不推荐，我下载的Linux Binaries (x64) 查看 nodejs文件夹 下有是否有node 和npm文件，如果没有重新下载安装。 建立软链接将npm和node命令转为全局命令 12ln -s /usr/local/src/nodejs/bin/npm /usr/local/bin/npmln -s /usr/local/src/nodejs/bin/node /usr/local/bin/node 检验node是否已全局可用1node -v cnpm如果想使用cnpm 可以全局安装后，建立软链接，同2，不再赘述 git安装12yum -y install gitgit --version hexo安装全局安装hexo1npm install -g hexo-cli 初始化hexo项目进入hexo项目文件夹，我的是在/home/apps/ 1234cd /home/apps/hexo init hexoblogcd hexoblognpm i 安装完成后目录如下 node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 配置 网站的初始配置都在_config.yml中，我们可以在其中修改大部分配置。 具体配置见 hexo官网 启动安装完成后，hollow world 终于可以打开了 123cd /home/apps/hexobloghexo shexo g -d 现在打开服务器ip 4000 端口即可看到Hellow world 页面啦 2018-11-15-hexo博客搭建过程记录-20181115 主题的使用hexo安装完成后切换主题极其简单，我现在用的是Material Design 风格的Hexo主题 indigo ,更多主题可以在 官网 查看，选择你心仪的主题即可，亦可自己开发DIY。 别忘了给作者start哦 12cd /home/apps/hexoblog/git clone https://github.com/yscoder/hexo-theme-indigo.git themes/indigo 然后将_config.yml中 theme 选项设为 indigo 即可 此主题需要安装依赖，具体步骤查看作者文档 文档 hexo管理工具如果我们每次写完都要把文件传到服务器，再 hexo g -d,那岂不是很麻烦，当然也可以接受，不过hexo-admin可以更方便的管理你的博文，是你在随便一个浏览器即可写作，美滋滋 看这里即可，使用极其简单 hexo-admin ##结束 如果不出意外，现在你已经可以写文章了，具体的文章写作和加载，请直接看官网吧。有啥意外可以问我😀😀😀","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.caopingping.com/tags/hexo/"},{"name":"node","slug":"node","permalink":"http://www.caopingping.com/tags/node/"}]},{"title":"centos下nginx的安装与自启","date":"2018-11-14T07:49:00.000Z","path":"2018/11/14/centos下nginx的安装与自启/","text":"老早就想买个服务器，可惜囊中羞涩，一直没有下手，前两天逛阿里云看见个云翼计划，赶紧踩着青春的尾巴买了一年ECS自己没事耍耍也是好的呀 阿里云翼计划 废话不多说，这就开始 准备工作 服务器一台 我用的是阿里云centos7 xshell 其它亦可 linux基本操作 nginx和配置我们一会还要安装node，node自己本身可以作为服务器进行驱动，但是node本身对文件的处理能力并不是很好，所以当我们的生产环境中应尽量使用nginx来处理静态的资源以及反向代理，同时也解决了node分布式以及负载均衡的相关问题。 安装 首先安装make gcc之类的东西，编译用 12yum -y install automake autoconf libtool makeyum install gcc gcc-c++ 选择nginx安装目录，我选的是 /usr/local/src 1cd /usr/local/src 一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。 123456wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.42.tar.gztar -zxvf pcre-8.42.tar.gzcd pcre-8.42./configuremakemake install 可以在ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/选择最新版本pcre 123456wget http://zlib.net/zlib-1.2.11.tar.gztar -zxvf zlib-1.2.11.tar.gzcd zlib-1.2.11./configuremakemake install 可以在http://zlib.net/选择最新版本zlib 安装ssl网络通信安全，功能丰富且自包含的开源安全工具箱12wget https://www.openssl.org/source/openssl-1.1.1.tar.gztar -zxvf openssl-1.1.1.tar.gz 可以在https://www.openssl.org/source/选择最新版本openssl 安装nginx Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：1234567891011121314wget http://nginx.org/download/nginx-1.4.2.tar.gztar -zxvf nginx-1.4.2.tar.gzcd nginx-1.4.2 ./configure --sbin-path=/usr/local/nginx/nginx \\--conf-path=/usr/local/nginx/nginx.conf \\--pid-path=/usr/local/nginx/nginx.pid \\--with-http_ssl_module \\--with-pcre=/usr/src/local/pcre-8.42 \\--with-zlib=/usr/src/local/zlib-1.2.11 \\--with-openssl=/usr/src/local/openssl-1.1.1 makemake install –with-pcre=/usr/src/local/pcre-8.42 指的是pcre-8.42 的源码路径。–with-zlib=/usr/src/local/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。 安装完成安装成功后 /usr/local/nginx 目录下如下123456789101112131415161718192021222324drwx------ 2 nobody root 4096 Nov 2 10:16 client_body_temp-rw-r--r-- 1 root root 1034 Nov 1 18:43 fastcgi.conf-rw-r--r-- 1 root root 1034 Nov 1 18:43 fastcgi.conf.default-rw-r--r-- 1 root root 964 Nov 1 18:43 fastcgi_params-rw-r--r-- 1 root root 964 Nov 1 18:43 fastcgi_params.defaultdrwx------ 2 nobody root 4096 Nov 2 10:16 fastcgi_tempdrwxr-xr-x 2 root root 4096 Nov 2 11:11 html-rw-r--r-- 1 root root 2837 Nov 1 18:43 koi-utf-rw-r--r-- 1 root root 2223 Nov 1 18:43 koi-windrwxr-xr-x 2 root root 4096 Nov 2 10:16 logs-rw-r--r-- 1 root root 3463 Nov 1 18:43 mime.types-rw-r--r-- 1 root root 3463 Nov 1 18:43 mime.types.default-rwxr-xr-x 1 root root 7177456 Nov 1 18:43 nginx-rw-r--r-- 1 root root 3937 Nov 13 16:14 nginx.conf-rw-r--r-- 1 root root 2685 Nov 1 18:43 nginx.conf.default-rw-r--r-- 1 root root 5 Nov 12 10:02 nginx.piddrwx------ 12 nobody root 4096 Nov 13 15:29 proxy_temp-rw-r--r-- 1 root root 596 Nov 1 18:43 scgi_params-rw-r--r-- 1 root root 596 Nov 1 18:43 scgi_params.defaultdrwx------ 2 nobody root 4096 Nov 2 10:16 scgi_temp-rw-r--r-- 1 root root 623 Nov 1 18:43 uwsgi_params-rw-r--r-- 1 root root 623 Nov 1 18:43 uwsgi_params.defaultdrwx------ 2 nobody root 4096 Nov 2 10:16 uwsgi_temp-rw-r--r-- 1 root root 3610 Nov 1 18:43 win-utf 启动12cd /usr/local/nginx/./nginx 现在打开浏览器，输入此机器IP即可看到 Welcome To Nginx 安装成功！ 将nginx加入可执行程序目录竟然每次操作nginx都要进入/usr/local/nginx/好麻烦有木有没关系 软链接来帮你/usr/local/bin目录是给用户放置自己的可执行程序的地方,我们只需在这里建立nginx的软链接即可全局执行nginx 1ln -s /usr/local/nginx/nginx /usr/local/bin/nginx 大功告成！ 设置nginx开机自启动每次开机我们都要启动nginx，同样巨麻烦，所以可以写一个自启动脚本，使其开机自启动，岂不美滋滋12cd /etc/rc.d/init.dvim nginxserver 这是nginx官网上的自启脚本，将这些粘贴进nginxserver 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \\# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ \"$NETWORKING\" = \"no\" ] &amp;&amp; exit 0nginx=\"/usr/local/nginx/nginx\"prog=$(basename $nginx)NGINX_CONF_FILE=\"/usr/local/nginx/nginx.conf\"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | grep \"configure arguments:.*--user=\" | sed 's/[^*]*--user=\\([^ ]*\\).*/\\1/g' -` if [ -n \"$user\" ]; then if [ -z \"`grep $user /etc/passwd`\" ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d \"=\" -f 2` if [ ! -d \"$value\" ]; then # echo \"creating\" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done fi&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $\"Starting $prog: \" daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $\"Stopping $prog: \" killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $\"Reloading $prog: \" killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case \"$1\" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $\"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;\" exit 2esac :wq保存退出 增加脚本的可执行权限 1chmod +x /etc/rc.d/init.d/nginxserver 添加脚本到开机自动启动项目中 123cd /etc/rc.d/init.dchkconfig --add nginxserverchkconfig nginxserver on 完事！","tags":[{"name":"linux","slug":"linux","permalink":"http://www.caopingping.com/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"http://www.caopingping.com/tags/nginx/"}]}]